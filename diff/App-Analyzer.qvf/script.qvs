///$tab About
/* 

    _______                      _______              ______                          
    ___    |_______________      ___    |____________ ___  /____  ____________________
    __  /| |__  __ \__  __ \     __  /| |_  __ \  __ `/_  /__  / / /__  /_  _ \_  ___/
    _  ___ |_  /_/ /_  /_/ /     _  ___ |  / / / /_/ /_  / _  /_/ /__  /_/  __/  /    
    /_/  |_|  .___/_  .___/      /_/  |_/_/ /_/\__,_/ /_/  _\__, / _____/\___//_/     
           /_/     /_/                                     /____/                      
        
    
    Copyright 2025 QlikTech International
    Created by Daniel Pilla, Distinguished Principal Presales Architect, Qlik

	About the "App Analyzer" app:
    
    The App Analyzer provides a comprehensive dashboard to analyze application metadata across a Qlik Sense tenant(s),
    providing developers and administrators a holistic view of the makeup of all of their applications. 

    This application iterates over application metadata API endpoints and uses additional calls to the quotas, items, 
    and spaces API endpoints.

    The data from the metadata endpoint includes:

      - reload time
      - base RAM footprint
      - reload peak RAM
      - field metadata including cardinality, tags, total count, RAM size
      - table metadata including fields, rows, key fields, RAM size
      ...and more

    Given that this application provides RAM statistics for both base RAM footprint and peak reload RAM, it is encouraged
    to use this application to track applications against tenant quota limits. The application exposes the data points to
    optimize the applications to keep them under those limits, as well as use trending analysis to anticipate when
    an application might hit a limit.

    Enjoy!

*/

///$tab ** Configuration **
Trace Configuration;

////////////////////////////////////////////////////////////////////////////////////////
// *Required* Configuration 

// IMPORTANT: To run this application, the user must be a "Tenant Admin" and must have an API Key, which requires the "Developer Role"
// and APIs to be enabled within the tenant.

/*
1. The name of the REST connection that will be used. You must first create a valid REST connection to any endpoint to Qlik Sense tenant.
		Example: '<Space>:<Connection Name>'
        			Note: ':<Connection Name>' is the relative path which will check for a connection in the current space.
		Example Connection: 
					URL: 			https://<tenant-name>.<region>.qlikcloud.com/api/v1/items
					Header: 		"Authorization"
					Header Value: 	"Bearer <token>"
		For reference on how to connect: 
					https://qlik.dev/tutorials/generate-your-first-api-key
*/
Set vu_rest_connection = ':monitoring_apps_REST';
   
/*
2. The full path to where you want to store your QVDs.
		Example: 'lib://<Space>:<DataFiles>'
        			Note: 'lib://:<Connection Name>' is the relative path which will check for a connection in the current space.
*/
Set vu_qvd_storage_connection = 'lib://:DataFiles';

////////////////////////////////////////////////////////////////////////////////////////
///$tab * Optional Configuration *
////////////////////////////////////////////////////////////////////////////////////////
// Optional Configuration (No need to change these unless you desire) 

// The number of days to fetch app metadata initially, before incrementally building. 
// Set this value to -1 to consume the full app metadata analysis in the application. 
// However, when reloading for a tenant with over 10,000 apps, the reload may time out after 3 hours. 
// In such cases, set this value to smaller increments (e.g., 7, 14, 30) and gradually increase it, 
// eventually setting it back to -1. This allows the app to reload in batches without exceeding the time limit.

// The complete batch process is as follows:
//                        
// 1. Set the "vu_app_metadata_initial_days_back" variable to 1.
// 2. Reload the application.
// 3. Repeat steps 1 and 2 while raising the number, e.g., 1 → 7, 7 → 30, 30 → 60, 60 → 90, 90 → 180.
// 4. Set the "vu_app_metadata_initial_days_back" variable to -1 (this indicates all time).
// 5. Reload the application to complete the batch process.
Set vu_app_metadata_initial_days_back 	= -1;

// CAUTION!
//	This variable allows loading historical session data beyond the default limit of 90 days from v1/licenses/consumption,
//	which includes high-level session information such as app ID, user ID, and session duration. By default, this data is
//	limited to the last 90 days due to constraints in v1/audits, which captures detailed session metrics like sheet views
//	and data exports. Enabling this variable and setting vu_sessions_initial_days_back to a value greater than 90 days results in
//	complete data for the last 90 days, but incomplete data for earlier periods. This feature is useful when detailed
//	session information is not required, allowing tracking of high-level user engagement with applications beyond 90 days.
//
// 	Use 1 to enable this feature and 0 to disable it. The default value is 0.
Set vu_enable_extended_session_history	= 0;

// The number of days back to fetch consumption data initially, before incrementally building. The default maximum is 90, 
// however this can be extended beyond 90 below with the 'vu_enable_extended_session_history' variable. Note that once this
// variable is set, it cannot be made larger. For example if it is first set to 30 and then set to 90, it will continue to
// increment from 30 days back. It is generally not advised to change this variable.
Set vu_sessions_initial_days_back 		= 90;

// Maximum days to store session data in QVDs is 365 by default, but this will be overridden to 90 if
// 'vu_slim_version_for_anonymous' is enabled. This value must always be greater than 'vu_sessions_initial_days_back', and if
// 'vu_enable_extended_session_history' is enabled with 'vu_sessions_initial_days_back' set above 365, adjust accordingly.
Set vu_session_rolling_range 			= 365;

// The timezone difference from GMT. Modifies the reload times and session times to the desired GMT offset.
//	Example 1: -5
//	Example 2: 5
Set vu_GMT_offset 						= 0;

// Store QVDs of high-level app metadata on every reload to track growth over time.
Set vu_track_app_meta_over_time			= 1;

// Days to retain the rolling app metadata.
Set vu_track_app_meta_retention			= 90;

// Width of app last reload date for grouping apps in this app.
Set vu_months_in_reload_interval 		= 3;

// The user field to best represent the user: 'Id', 'Name', 'Subject', 'Email'
Set vu_personal_space_user_field = 'Name';

// Set the default filter for the Sessions table on the Sessions Overview sheet. Defaults to All.
// Can be one of: 
//		All
//    	Totals
//    	CMTD
//    	PMTD
Set vu_sessions_table_preset_filter = 'Totals';

// Set the default filter for the first sessions container on the Sessions Overview sheet. Defaults to Sessions by User.
// Can be one of: 
//		Sessions by User
//    	Users by App
//    	Concurrent Users by App
//    	Sessions by User
//		Apps Viewed by User
Set vu_sessions_container_1_preset_filter = 'Sessions by App';

// Set the default filter for the second sessions container on the Sessions Overview sheet. Defaults to Sessions Over Time.
// This will be overwritten to 'Concurrent Sessions Over Time' if on an anonymous-enabled tenant
// Can be one of: 
//		Sessions Over Time
//    	Users Over Time
//    	Concurrent Sessions Over Time
//    	Concurrent Users Over Time
Set vu_sessions_container_2_preset_filter = 'Sessions Over Time';

// Set the default filter for the Sessions by Hour pivot on the Session Time Analysis sheet. Defaults to Sessions.
// Can be one of: 
//		Sessions
//		Sessions CM
//		Sessions PMTD
//		Sessions PM
//		Users
//		Users CM
//		Users PMTD
//		Users PM
//    	Concurrent Users
//    	Concurrent Users CM
//		Concurrent Users PMTD
//		Concurrent Users PM
Set vu_sessions_pivot_preset_filter = 'Users';

// Drops many tables/fields to decrease RAM, as all apps in anonymous access tenants contribute to purchased RAM.
// Set to 1 if desired, default 0.
// This will be auto-applied for anonymous-enabled tenants.
//
// Note that if the 'vu_enable_extended_session_history' variable is used, the 'vu_session_rolling_range' variable
// will not be auto-truncated to 90 days, as is would be otherwise for the "slim" version of the app.
Set vu_slim_version_for_anonymous = 0;


////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////
// Multitenant App Configuration

// This application has support for multi-tenancy. If this app is designated as a "parent" app, it loads in the generated
// QVDs of all "child" apps from a centralized location (e.g., AWS S3, Azure Blob, or Google Cloud Storage where the 
// "QlikMetaCollection" directory resides) and does not directly harvest any data itself, meaning it depends on the existence 
// of "child" apps. If designated as a child app, it writes out all of its final QVDs post harvest to a centralized location.

Set vu_multi_tenant_enabled 			= 0;	// To enable Multi-Tenant app support, regardless of "Parent" or "Child" (1 or 0)

Set vu_is_parent_app 					= 0;	// If this application is to be the parent app across varying tenants (1 or 0)

// The connection to the parent directory of the QlikMetaCollection directory, which houses all of the multitenant metadata.
// This is the root location to read/write all QVDs to so that they can be loaded across tenants (S3, Azure Blob, or Google 
// Cloud Storage). The final path will resemble "QlikMetaCollection/Tenants/<TenantID>/Monitoring/<Monitoring App Name>/<Table>.qvd". 
// The location below should point to the parent directory of the "QlikMetaCollection" folder. If the "QlikMetaCollection" 
// folder does not exist, it will be automatically created.

// **Azure Blob, AWS S3, and Google CLoud Storage have been tested and confirmed to work without any modifications**
// Parent directory of the "QlikMetaCollection" folder (trailing slash optional)
Set vu_qlik_meta_collection_parent_dir = 'lib://:';

////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////
// Visual Thresholds - change these if you want to highlight specific apps based on these attributes

Set vAppRAMToQuotaPercentThreshold				= .8;			// The percentage of your tenant threshold for App RAM size for flagging apps that are getting close
Set vAppReloadPeakRAMToQuotaPercentThreshold	= .8;			// The percentage of the 5 GB reload peak RAM cap for flagging apps that are getting close
Set vAppRecordCountThreshold 					= 100000000; 	// Number of records in an app
Set vTableRecordCountThreshold 					= 50000000; 	// Number of records in a table
Set vFieldValueCountThreshold 					= 10000000; 	// Number of field records
Set vFieldCardinalityThreshold 					= 1000000; 		// Number of distinct field values
Set vNoOfFields 								= 150; 			// Number of Distinct Fields
Set vReloadCPUTimeThreshold 					= 1800000; 		// CPU Time spent on last reload (milliseconds); default = 1,800,000 = 30 Minutes

////////////////////////////////////////////////////////////////////////////////////////

///$tab Variables
Sub variables
  
  	//// General System  & Date Time Variables
    Set ThousandSep		=',';
    Set DecimalSep		='.';
    Set TimeFormat		= 'hh:mm:ss';
    Set DateFormat		= 'YYYY-MM-DD';
    Set TimestampFormat	= 'YYYY-MM-DD hh:mm:ss';
    Set FirstWeekDay=6;
    Set BrokenWeeks=1;
    Set ReferenceDay=0;
    Set FirstMonthOfYear=1;
    Set CollationLocale='en-US';
    Set MonthNames='Jan;Feb;Mar;Apr;May;Jun;Jul;Aug;Sep;Oct;Nov;Dec';
    Set LongMonthNames='January;February;March;April;May;June;July;August;September;October;November;December';
    Set DayNames='Mon;Tue;Wed;Thu;Fri;Sat;Sun';
    Set LongDayNames='Monday;Tuesday;Wednesday;Thursday;Friday;Saturday;Sunday';
    Set NumericalAbbreviation='3:k;6:M;9:B;12:T;15:P;18:E;21:Z;24:Y;-3:m;-6:μ;-9:n;-12:p;-15:f;-18:a;-21:z;-24:y';

    Set vCapacityLicenseStandardTierQuota = 10737418240; // 10 GB for the standard tier app base RAM quota under the capacity license
    Set vAppRAMPeakReloadSizeQuota 		= 42949672960; // 40 GB for reload peak RAM  
    Set CreateSearchIndexOnReload			= 1;	       // to assist search results in app
    Search Exclude '*ID','_*','*Time*','*Duration*','*Date*'; // Exclude these fields from the global search.
    Set HidePrefix='_';

    Let vu_tenant_fqdn 	= GetSysAttr('tenantUrl');
    Let vu_tenant_alias = GetSysAttr('tenantUrlAlias');

  	//// Run-time variables
    Let vStartTime 						= Now(1);
    Let vSessionsTableColumnFilter		= '$(vu_sessions_table_preset_filter)';
    Let vSessionsPivotMeasureModifier	= '$(vu_sessions_pivot_preset_filter)';
    Let vSessionsContainer1Tab			= '$(vu_sessions_container_1_preset_filter)';
    Let vSessionsContainer2Tab			= '$(vu_sessions_container_2_preset_filter)';
    Set vSessionsPivotDimensionsModifier= 'SessionUserName';
    Set vSessionsPivotMeasureModifier	= 'Sessions';
    Set vSessionsPivotColumnModifier  	= 'SessionHourAMPM';
    Let vAppQVDName						= Lower(Replace('$(app_name)',' ','_'));
    Set vOutputQVDName					= '$(vu_qvd_storage_connection)/$(vAppQVDName)_$1_$2.qvd';
    Set vRollingQVDName					= '$(vu_qvd_storage_connection)/app_analyzer_rolling.qvd';
    Let vReloadDiffFromGMTString		= If(vu_GMT_offset=0,'GMT-00:00',
        If(vu_GMT_offset<0,'GMT-' & Right('0' & Replace(vu_GMT_offset,'-',''),2) & ':00',
        If(vu_GMT_offset>0,'GMT+' & Right('0' & vu_GMT_offset,2) & ':00'))); 
    Let vReloadTimeDiffFromGMT			= ConvertToLocalTime('$(vStartTime)','$(vReloadDiffFromGMTString)') - GMT();
    Set vu_personal_space_user_list  	= 'id','name','subject','email';
    Let v90BackGMT				 		= Date(Today(1) - 90);
    Let vSheetTitleAddedDate			= MakeDate(2024,12,13);

    If $(vu_sessions_initial_days_back)>0 Then
        If $(vu_enable_extended_session_history)=1 Then
            Let vInitialDaysBack = Date(Today(1) - $(vu_sessions_initial_days_back));
        Else
            Let vInitialDaysBack = If($(vu_sessions_initial_days_back)<=90,Date(Today(1) - $(vu_sessions_initial_days_back)),$(v90BackGMT));
        End if
    Else
        Let vInitialDaysBack = Date('$(v90BackGMT)');
    End if

    Let vu_app_metadata_initial_days_back 	= If(IsNum(vu_app_metadata_initial_days_back),vu_app_metadata_initial_days_back,-1);
    Set vMaxAppsPerReloadLimit				= 10000;

    Let vConsumptionQVD			 			= '$(vOutputQVDName(Consumption,$(app_schema_version)))';
    Let vConsumptionMinutes					= 1;
    Set vSessions							= 1;
    Set vSheetConsumptionNoNewRecords 		= 0; // Instantiate as zero
    Set vAppExportNoNewRecords 				= 0; // Instantiate as zero
    Set vAppContainsLargeAppConsumption 	= 0; // Instantiate as zero
    Set vAppLargeAppConsumeNoNewRecords 	= 0; // Instantiate as zero
    Let vAppMetadataQVD 					= '$(vOutputQVDName(AppReloadCPUMetadata,$(app_schema_version)))';
    Let vAppExportQVD 						= '$(vOutputQVDName(ExportFromApp,$(app_schema_version)))';
    Let vAppLargeAppsQVD 					= '$(vOutputQVDName(LargeAppConsumption,$(app_schema_version)))';
    Let vIncrementalQVDsAvailable			= If(Len(FileTime('$(vAppMetadataQVD)'))>0,1,0);  // Check to see that incremental QVDs are available
    Let vIncrementalExportQVDsAvailable 	= If(Len(FileTime('$(vAppExportQVD)'))>0,1,0);  // Check to see that incremental QVDs are available
    Let vIncrementalLargeAppsQVDsAvailable= If(Len(FileTime('$(vAppLargeAppsQVD)'))>0,1,0);  // Check to see that incremental QVDs are available
    Let vRollingQVDsAvailable	 			= If(Len(FileTime('$(vRollingQVDName)'))>0,1,0);  // Check to see that rolling QVD is available
    Let vIncrementalMessage 				= If($(vIncrementalQVDsAvailable)=1,'Incremental QVDs found','No Incremental QVDs found. Do not panic. I can fix that.');
    If $(vu_is_parent_app) = 0 then
      Trace $(vIncrementalMessage);
    End if

    Let vLastReloadTime 				= TimeStamp(ReloadTime());

    Set vRollingLineSelect = 'App RAM (MB)'; // Set default view for the Rolling data visualizations.

  	//// Calendar Variables
    Let vLast7Days 			=	Num(Floor(TimeStamp('$(vStartTime)'-7) + $(vReloadTimeDiffFromGMT)));
    Let vLast30Days	 		=	Num(Floor(TimeStamp('$(vStartTime)'-30) + $(vReloadTimeDiffFromGMT)));
    Let vLast60Days 		=	Num(Floor(TimeStamp('$(vStartTime)'-60) + $(vReloadTimeDiffFromGMT)));
    Let vLast90Days 		=	Num(Floor(TimeStamp('$(vStartTime)'-90) + $(vReloadTimeDiffFromGMT)));

  	//// Indicators
    Set i_up_down 			= 'Pick($1+2,'' 📉'','' '' &Repeat('' '',9),'' 📈'')';
    
  	//// Colors
    Set c_light_gray		= 'RGB(240,240,240)';
    Set c_threshold_red		= 'RGB(165,67,67)';
    Set c_red				= 'RGB(204,102,119)';
    Set c_orange 			= 'RGB(233,141,54)'; 
    Set c_yellow			= 'RGB(221,204,119)';
    Set c_blue				= 'RGB(68,119,170)';
    Set c_green				= 'RGB(17,119,51)';
    Set c_gray 				= 'RGB(150,150,150)';
    Set c_lightred 			= 'RGB(240,209,214)';
    Set c_lightblue 		= 'RGB(188,181,201)'; 
    //// ARGB colors -- requires input value to set the intensity (alpha) value of the color. Example using field [dual90]:  $(c_red_alpha(dual90)) 
    Set c_red_alpha			= 'ARGB($1,192,57,43)';
    Set c_orange_alpha		= 'ARGB($1,233,141,54)'; 
    Set c_yellow_alpha		= 'ARGB($1,221,204,119)';
    Set c_blue_alpha		= 'ARGB($1,16,101,128)';
    Set c_green_alpha		= 'ARGB($1,17,119,51)';
    Set c_gray_alpha		= 'ARGB($1,150,150,150)';
    Set c_red_breeze_alpha	= 'ARGB($1,155,58,59)';
    Set c_orange_breeze_alpha= 'ARGB($1,233,141,54)';
    Set c_teal_breeze_alpha	= 'ARGB($1,19,118,122)';
    Set c_green_breeze_alpha= 'ARGB($1,101,177,99)';
    Set c_red_0_green_alpha	= 'IF($1=0,c_red,ARGB($1,101,177,99))';

End Sub
///$tab Set Incremental
Sub set_incremental

    If $(vu_is_parent_app)=0 Then

        If $(vIncrementalQVDsAvailable)=1 Then

            Trace Looking to load: $(vConsumptionQVD).;
            Let file_size = If(IsNull(FileSize('$(vConsumptionQVD)')),0,FileSize('$(vConsumptionQVD)'));

            If file_size > 0 Then // this handles for when there were zero sessions on the first load, i.e., new tenant with programmatic deployment
                Trace File size is $(file_size) bytes;
                Trace Fetching data from: $(qvd_name);
                Trace $(table);

                ConsumptionMaxEndTimeTemp:
                Load
                    SessionEndTime
                From '$(vConsumptionQVD)'(qvd)
                Where Not Exists(SessionEndTime);

                ConsumptionMaxEndTime:
                Load 
                    Max(SessionEndTime) AS ConsumptionMaxEndTime
                Resident ConsumptionMaxEndTimeTemp;

                Let vIncrementalStartTime = Peek('ConsumptionMaxEndTime',0,'ConsumptionMaxEndTime') - (1 / 24 / 60);

                Drop Tables ConsumptionMaxEndTimeTemp,ConsumptionMaxEndTime;

                Let vIncrementalStartTimeDisplay = TimeStamp('$(vIncrementalStartTime)','MM/DD/YYYY hh:mm:ss.fff');

                Trace Incremental will resume from: $(vIncrementalStartTimeDisplay);

                Set vIncrementalStartTimeDisplay =;

            Else

                Let vIncrementalStartTime = '$(vInitialDaysBack)';

            End If

        Else

            Trace $(vIncrementalMessage);

            Let vIncrementalStartTime = '$(vInitialDaysBack)';

        End If

    End If
    
End Sub
///$tab Check Version
Sub check_version

    // check to see whether the app is the latest version

    LIB Connect To '$(vu_rest_connection)';

    RestConnectorMasterTable:
    SQL SELECT 
        "id",
        "name",
        "version",
        "source",
        "qcmaInstaller",
        "oemInstaller"
    FROM JSON (wrap on) "root"
    WITH CONNECTION (  
        URL "https://raw.githubusercontent.com/qlik-oss/qlik-cloud-monitoring-apps/main/manifests/resources.json",
        HTTPHEADER "Authorization" ""
    );

    [Version]:
    Load	
        [version]
    Resident RestConnectorMasterTable
    Where name='$(app_name)';

    Drop Table RestConnectorMasterTable;

    Let vLatestVersion = Peek('version',0,'Version');
    Let vIsLatestVersion = If('$(vLatestVersion)'='v$(app_version)',1,0);

    Drop Table Version;

End Sub
///$tab Tenant Metadata
Sub get_tenant_metadata

    LIB Connect To '$(vu_rest_connection)';

    RestConnectorMasterTable:
    SQL SELECT 
        "__KEY_root",
        (SELECT 
            "id",
            "name",
            "datacenter",
            "created",
            "status",
            "__FK_data",
            "__KEY_data",
            (SELECT 
                "@Value",
                "__FK_hostnames"
            FROM "hostnames" FK "__FK_hostnames" ArrayValueAlias "@Value")
        FROM "data" PK "__KEY_data" FK "__FK_data")
    FROM JSON (wrap on) "root" PK "__KEY_root"
    WITH CONNECTION (  
      URL "https://$(vu_tenant_fqdn)/api/v1/tenants"
    );

    [Hostname]:
    Load	
        [@Value] AS Hostname
    Resident RestConnectorMasterTable
    Where Not IsNull([__FK_hostnames]);


    [TenantMetadata]:
    Load	
        [id] AS TenantID,
        [name] AS TenantName,
        [datacenter] AS TenantDataCenter,
        Date([created]) AS TenantCreatedDate,
        [status] AS TenantStatus,
        Peek('Hostname',0,'Hostname') AS Hostname,
        TimeStamp('$(vStartTime)') AS LastReloadStartTime
    Resident RestConnectorMasterTable
    Where Not IsNull([__FK_data]);

    Drop Table Hostname;
    Drop Table RestConnectorMasterTable;

    Let vTenantID = Peek('TenantID',0,'TenantMetadata');

End Sub
///$tab Check License
Sub check_license

    // check to see whether the tenant is on a capacity license

    LIB Connect To '$(vu_rest_connection)';

    RestConnectorMasterTable:
    SQL SELECT 
        "__KEY_root",
        (SELECT 
            "name",
            "__FK_allotments"
        FROM "allotments" FK "__FK_allotments"),
        (SELECT 
            "name" AS "name_u0",
            "__KEY_parameters",
            "__FK_parameters",
            (SELECT 
            	"resourceType",
                "quantity",
                "title",
                "__FK_values"
            FROM "values" FK "__FK_values")
        FROM "parameters" PK "__KEY_parameters" FK "__FK_parameters")
    FROM JSON (wrap on) "root" PK "__KEY_root"
    WITH CONNECTION (  
        URL "https://$(vu_tenant_fqdn)/api/v1/licenses/overview"
    );

    [CheckLicense]:
    Load	
        [name]
    Resident RestConnectorMasterTable
    Where [name]='fullUser';
    
    [AnonymousLicense]:
    Load	
        [__KEY_parameters] AS _AnonymousLicenseKey
    Resident RestConnectorMasterTable
    Where Match(name_u0,'anonymousConcurrentSessions','anonymousCapacity');
    
    Left Join (AnonymousLicense)
    Load	
    	[quantity] AS AnonymousLicenseQuantity,
        [title] AS AnonymousLicenseType,
        [__FK_values] AS _AnonymousLicenseKey
    Resident RestConnectorMasterTable
    Where Not IsNull([__FK_values]);
    
    [LargeAppsConsumeLicense]:
    Load	
        [__KEY_parameters] AS _LargeAppsLicenseKey
    Resident RestConnectorMasterTable
    Where Match(name_u0,'appSizeTotalDefault');
    
    Left Join (LargeAppsConsumeLicense)
    Load	
    	[quantity] AS LargeAppsConsumeQuantity,
        [__FK_values] AS _LargeAppsLicenseKey
    Resident RestConnectorMasterTable
    Where Not IsNull([__FK_values])
    And resourceType='app-usage.quota.appSizeTotalDefault';
    
    Drop Table RestConnectorMasterTable;
    Drop Fields _AnonymousLicenseKey,_LargeAppsLicenseKey;
    
    Left Join (TenantMetadata)
    Load
    	*
    Resident LargeAppsConsumeLicense;
    
    // Instantiate vars
    Set vHasLargeApps=-1;
    Set vAnonymousConcurrentSessions=-1;
    Set vAnonymousAppCapacity=-1;
    Set vAnonymousConcurrentApps=-1;
    Set vIsAnonymousLicense=-1;
    
    If NoOfRows('LargeAppsConsumeLicense')>0 Then
    	Let vHasLargeApps = 1;
    End if
    
    Drop Table LargeAppsConsumeLicense;
    
    If NoOfRows('AnonymousLicense')>0 Then
    	Let vAnonymousConcurrentSessions = LookUp('AnonymousLicenseQuantity','AnonymousLicenseType','Anonymous Concurrent Sessions','AnonymousLicense');
    	Let vAnonymousAppCapacity = LookUp('AnonymousLicenseQuantity','AnonymousLicenseType','Anonymous Capacity','AnonymousLicense');
    
    	Set vIsAnonymousLicense = 1;
    	Set vu_slim_version_for_anonymous = 1;
        Set vSessionsContainer2Tab = 'Concurrent Sessions Over Time';
        Set vAnonymousConcurrentApps = 50;
    End if
    
	Set vIsCapacityLicense = 0;
    If NoOfRows('CheckLicense') > 0 And $(vIsAnonymousLicense)<>1 Then
        Set vIsCapacityLicense = 1; // App RAM size quota for non-anonymous capacity license must be hardcoded at 10 GB
    End If

    Drop Tables 
    	CheckLicense
        ,AnonymousLicense
    ;
    
    If $(vu_slim_version_for_anonymous)=1 And $(vu_enable_extended_session_history)<>1 Then
        Set vu_session_rolling_range = 90; // Override this setting to ensure app remains slim while in slim version unless set to extended sessions
    End If
    
    Let vMaxSessionAge = TimeStamp(Date(Today(1)) - $(vu_session_rolling_range));
        
End Sub



///$tab Tenant Quotas
Sub get_quota

    LIB Connect To '$(vu_rest_connection)';

    RestConnectorMasterTable:
    SQL SELECT 
        "id",
        "type",
        "__KEY_data",
        (SELECT 
            "quota",
            "unit",
            "usage",
            "__KEY_attributes",
            "__FK_attributes"
        FROM "attributes" PK "__KEY_attributes" FK "__FK_attributes")
    FROM JSON (wrap off) "data" PK "__KEY_data"
    WITH CONNECTION (  
      URL "https://$(vu_tenant_fqdn)/api/v1/quotas?reportUsage=true"
    );

    [Quotas]:
    Load	
        [id] as QuotaResource,
        [type] as QuotaType,
        '$(vTenantID)' AS TenantID,
        [__KEY_data]
    Resident RestConnectorMasterTable
    Where not IsNull([__KEY_data]);

    Left Join(Quotas)
    Load	
        If($(vIsCapacityLicense)=1 and [unit]='bytes',$(vCapacityLicenseStandardTierQuota),
        	(If([unit]='bytes' and [quota]<>-1,[quota],If([unit]='bytes','Unlimited'))))  as Quota_Bytes,
        If($(vIsCapacityLicense)=1 and [unit]='bytes',$(vCapacityLicenseStandardTierQuota)/(1024*1024),
        	(If([unit]='bytes' and [quota]<>-1,[quota]/(1024*1024),If([unit]='bytes','Unlimited'))))  as Quota_MB,
        If($(vIsCapacityLicense)=1 and [unit]='bytes',$(vCapacityLicenseStandardTierQuota)/(1024*1024*1024),
        	(If([unit]='bytes' and [quota]<>-1,[quota]/(1024*1024*1024),If([unit]='bytes','Unlimited'))))  as Quota_GB,
        If([unit]='spaces' and [quota]<>-1,[quota],If([unit]='spaces','Unlimited')) as QuotaSpace,
        [unit] as QuotaUnit,
        [usage] as QuotaUsage,
        [__FK_attributes] as [__KEY_data]
    Resident RestConnectorMasterTable
    Where not IsNull([__FK_attributes]);

    Drop Table RestConnectorMasterTable;
    Drop Field [__KEY_data];

    QuotaMemBytes:
    Load
        If(Quota_Bytes='Unlimited',999999999999999999999999999999999999,Quota_Bytes) as Quota_Bytes
    Resident Quotas
    Where QuotaResource='app_mem_size';

    AppRAMSizeQuotas:
    Load
        If(Peek('Quota_Bytes',0,'QuotaMemBytes')<>999999999999999999999999999999999999,Peek('Quota_Bytes',0,'QuotaMemBytes'),'Unlimited') AS AppRAMSizeQuota,
        Peek('Quota_Bytes',0,'QuotaMemBytes')*$(vAppRAMToQuotaPercentThreshold) AS AppRAMSizeThreshold,
        $(vAppRAMPeakReloadSizeQuota)*$(vAppReloadPeakRAMToQuotaPercentThreshold) AS AppRAMPeakReloadSizeThreshold,
        $(vAppRecordCountThreshold) AS AppRecordCountThreshold,
        $(vTableRecordCountThreshold) AS TableRecordCountThreshold,
        $(vFieldValueCountThreshold) AS FieldValueCountThreshold,
        $(vFieldCardinalityThreshold) AS FieldCardinalityThreshold,
        $(vNoOfFields) AS NoOfFields,
        $(vReloadCPUTimeThreshold) AS ReloadCPUTimeThreshold,
        '$(vTenantID)' AS TenantID
    Autogenerate 1;

    Drop Table QuotaMemBytes;
    Drop Field Quota_Bytes;

End Sub

///$tab Get User Field
Sub get_user_field

    Lookup_UserVariable_FieldName:
    Load * Inline [
        UserVariable	,FieldName
        id				,AppOwnerID
        subject			,AppOwnerSubject
        email			,AppOwnerEmail
        name			,AppOwnerName
    ];

    If Match(Lower('$(vu_personal_space_user_field)'),$(vu_personal_space_user_list)) Then

        Trace Using '$(vu_personal_space_user_field)' to construct 'Personal' space names;

        Let vPersonalUserField = Lookup('FieldName','UserVariable',Lower('$(vu_personal_space_user_field)'),'Lookup_UserVariable_FieldName');

    Else

        Trace The value for the variable 'vu_personal_space_user_field' must contain one of: $(vu_personal_space_user_list);
        Trace The value found was: '$(vu_personal_space_user_field)';
        Trace Defaulting to 'Subject';

        Set vPersonalUserField = 'AppOwnerSubject';

    End If
    
    Drop Table Lookup_UserVariable_FieldName;
  
End Sub
///$tab OAuth Clients
Sub get_oauth_clients

  	// subroutine to fetch oauth clients so that they can be easily excluded from analysis as they consume user sessions

    Set vParams = 'limit=100';

    Do
    
        LIB Connect To '$(vu_rest_connection)';

        RestConnectorMasterTable:
        SQL SELECT 
            "__KEY_root",
            (SELECT 
                "clientName"
            FROM "data" PK "__KEY_data" FK "__FK_data"),
            (SELECT 
                (SELECT 
                    "href",
                    "__FK_next"
                FROM "next" FK "__FK_next")
            FROM "links" PK "__KEY_links" FK "__FK_links")
        FROM JSON (wrap on) "root" PK "__KEY_root"
        WITH CONNECTION (  
          URL "https://$(vu_tenant_fqdn)/api/v1/oauth-clients?$(vParams)"
        );
        
        [OAuthClients]:
        Load
            [clientName] as OAuthClientName
        Resident RestConnectorMasterTable
        Where Not IsNull([clientName]);

        NextURL:
        Load	
            [href] as NextURL
        Resident RestConnectorMasterTable
        Where Not IsNull([__FK_next]);

        Drop Table RestConnectorMasterTable;

        Let vParams = SubField(Peek('NextURL',0,'NextURL'),'?',-1);
        Let vNextURLRows = NoOfRows('NextURL');

        Drop Table NextURL;

    Loop While $(vNextURLRows)>0;
    
	Map_OAuthClientName: // No map yet to support OEM Dash
    Load Distinct
    	OAuthClientName & '|$(vTenantID)' AS OAuthClientNameKey,
        1
    Resident OAuthClients;
    
    Drop Table OAuthClients;
      
End Sub
///$tab Users
Sub get_users

    Set vParams = 'limit=100';

    Do

      LIB Connect To '$(vu_rest_connection)';

      RestConnectorMasterTable:
      SQL SELECT 
          "__KEY_root",
          (SELECT 
              "__KEY_links",
              "__FK_links",
              (SELECT 
                  "href",
                  "__FK_self"
              FROM "self" FK "__FK_self"),
              (SELECT 
                  "href" AS "href_u0",
                  "__FK_next"
              FROM "next" FK "__FK_next")
          FROM "links" PK "__KEY_links" FK "__FK_links"),
          (SELECT 
              "id",
              "tenantId",
              "created",
              "lastUpdated",
              "status",
              "name",
              "subject",
              "email",
              "__KEY_data",
              "__FK_data",
              (SELECT 
                  "@Value",
                  "__FK_roles"
              FROM "roles" FK "__FK_roles" ArrayValueAlias "@Value"),
              (SELECT 
                  "__KEY_links_u0",
                  "__FK_links_u0",
                  (SELECT 
                      "href" AS "href_u1",
                      "__FK_self_u0"
                  FROM "self" FK "__FK_self_u0")
              FROM "links" PK "__KEY_links_u0" FK "__FK_links_u0")
          FROM "data" PK "__KEY_data" FK "__FK_data")
      FROM JSON (wrap on) "root" PK "__KEY_root"
      WITH CONNECTION (  
        URL "https://$(vu_tenant_fqdn)/api/v1/users?$(vParams)"
      );


      Users:
      Load	
          [id] as AppOwnerID,
  //         [id] AS UserID,
  //         [tenantId],
  //         Date([created]) AS AppOwnerCreatedDate,
  //         Date([lastUpdated]) AS AppOwnerLastUpdatedDate,
          [status] as AppOwnerStatus,
          [name] as AppOwnerName,
          [subject] as AppOwnerSubject,
          If(Len([email])>0,[email],'[None]') as AppOwnerEmail
      Resident RestConnectorMasterTable
      Where Not IsNull([__FK_data])
      And Match(status,'disabled','active');

      NextURL:
      Load	
          [href_u0] AS NextURL
      Resident RestConnectorMasterTable
      Where Not IsNull([__FK_next]);

      Drop Table RestConnectorMasterTable;

      Let vParams = SubField(Peek('NextURL',0,'NextURL'),'?',-1);
      Let vNextURLRows = NoOfRows('NextURL');

      Drop Table NextURL;

    Loop While $(vNextURLRows)>0;

    Concatenate(Users)
    Load
        '[Unknown]' 	as AppOwnerID,
        '[Unknown]' 	as AppOwnerStatus,
        '[Unknown]'  	as AppOwnerName,
        '[Unknown]' 	as AppOwnerSubject,
        '[Unknown]'	as AppOwnerEmail
    AutoGenerate(1);

    Concatenate(Users)
    Load
        '[Qlik Sense Enterprise Client-Managed]' 	as AppOwnerID,
        '[Qlik Sense Enterprise Client-Managed]' 	as AppOwnerStatus,
        '[Qlik Sense Enterprise Client-Managed]'  	as AppOwnerName,
        '[Qlik Sense Enterprise Client-Managed]' 	as AppOwnerSubject,
        '[Unknown]'								as AppOwnerEmail
    AutoGenerate(1);

    Concatenate(Users)
    Load
        '[QlikView Publisher]' 	as AppOwnerID,
        '[QlikView Publisher]' 	as AppOwnerStatus,
        '[QlikView Publisher]'  as AppOwnerName,
        '[QlikView Publisher]' 	as AppOwnerSubject,
        '[Unknown]'			as AppOwnerEmail
    AutoGenerate(1);

    Map_AppOwner_Exists:
    Mapping Load Distinct
        AppOwnerID,
        1
    Resident Users;

    Map_UserID_AppOwnerName: // No map yet to support OEM Dash
    Load Distinct
        AppOwnerID,
        AppOwnerName
    Resident Users;

    Map_UserID_AppOwnerID:
    Mapping Load Distinct
        AppOwnerID,
        AppOwnerID
    Resident Users;

    Map_UserID_AppOwnerSubject: // No map yet to support OEM Dash
    Load Distinct
        AppOwnerID,
        AppOwnerSubject
    Resident Users;

    Map_UserID_AppOwnerSubject_OEM: // Need as mapping is done in "Apps" section for OEM field
    Mapping Load Distinct
        AppOwnerID,
        AppOwnerSubject
    Resident Users;

    Map_UserID_AppOwnerEmail:
    Mapping Load Distinct
        AppOwnerID,
        AppOwnerEmail
    Resident Users;

    Call get_user_field

    Map_UserID_$(vPersonalUserField):
    Mapping Load Distinct
        AppOwnerID,
        $(vPersonalUserField)
    Resident Users;

End Sub
///$tab Spaces
Sub get_spaces

    Set vParams = 'limit=100';

    [Spaces]:
    Load * Inline [SpaceID];


    Do

      LIB Connect To '$(vu_rest_connection)';

      RestConnectorMasterTable:
      SQL SELECT 
          "__KEY_root",
          (SELECT 
              "id",
              "type",
              "ownerId",
              "tenantId",
              "name",
              "description",
              "createdAt",
              "createdBy",
              "updatedAt",
              "__KEY_data",
              "__FK_data",
              (SELECT 
                  "__KEY_meta",
                  "__FK_meta"
              FROM "meta" PK "__KEY_meta" FK "__FK_meta"),
              (SELECT 
                  "__KEY_links",
                  "__FK_links"
              FROM "links" PK "__KEY_links" FK "__FK_links")
          FROM "data" PK "__KEY_data" FK "__FK_data"),
          (SELECT 
              "__KEY_links_u0",
              "__FK_links_u0",
              (SELECT 
                  "href" AS "href_u2",
                  "__FK_next"
              FROM "next" FK "__FK_next")
          FROM "links" PK "__KEY_links_u0" FK "__FK_links_u0")
      FROM JSON (wrap on) "root" PK "__KEY_root"
      WITH CONNECTION (  
        URL "https://$(vu_tenant_fqdn)/api/v1/spaces?$(vParams)"
      );

      Concatenate (Spaces)
      Load	
          [id] as SpaceID,
          Capitalize([type]) as SpaceType,
          [ownerId] as SpaceOwnerID,
          // [tenantId],
          [name] as SpaceName,
          [description] as SpaceDescription,
          Timestamp(Timestamp([createdAt]) + $(vReloadTimeDiffFromGMT)) AS SpaceCreatedTime,
          [createdBy] as SpaceCreatedBy
          // [updatedAt],
          // [__KEY_data],
          // [__FK_data] as [__KEY_root]
      Resident RestConnectorMasterTable
      Where not IsNull([__FK_data]);

      NextURL:
      Load	
          [href_u2] as NextURL
      Resident RestConnectorMasterTable
      Where not IsNull([__FK_next]);

      Drop Table RestConnectorMasterTable;

      Let vParams = SubField(Peek('NextURL',0,'NextURL'),'?',-1);
      Let vNextURLRows = NoOfRows('NextURL');

      Drop Table NextURL;

    Loop while $(vNextURLRows)>0;
    
    Concatenate(Spaces)
    Load
        '[Staged]' as SpaceID,
        '[Staged]' as SpaceName,
        '[Staged]' as SpaceType
    AutoGenerate(1);

    AllSpacesMap:
    Mapping Load Distinct
        SpaceID,
        1
    Resident Spaces;
    
    Map_SpaceID_SpaceName:
    Mapping Load Distinct
        SpaceID,
        Text(SpaceName) AS SpaceName
    Resident Spaces;

End Sub

///$tab Apps
Sub get_apps

    Set vParams = 'limit=100&resourceType=app,qvapp&noActions=true';
    Set vAppLoop = 1;

    Do

      LIB Connect to '$(vu_rest_connection)';

      RestConnectorMasterTable:
      SQL SELECT 
          "__KEY_root",
          (SELECT 
              "name" AS "name_u0",
              "resourceCustomAttributes",
              "resourceUpdatedAt",
              "resourceType",
              "resourceId",
              "resourceCreatedAt",
              "id" AS "id_u0",
              "createdAt",
              "updatedAt",
              "creatorId",
              "updaterId",
              "tenantId",
              "isFavorited" AS "isFavorited_u0",
              "ownerId" AS "ownerId_u0",
              "description" AS "description_u0",
              "__KEY_data",
              "__FK_data",
              (SELECT 
                  "_resourcetype",
                  "createdDate",
                  "description",
                  "dynamicColor",
                  "hasSectionAccess",
                  "id",
                  "lastReloadTime",
                  "modifiedDate",
                  "name",
                  "originAppId",
                  "owner",
                  "ownerId",
                  "publishTime",
                  "published",
                  "spaceId",
                  "thumbnail",
                  "encrypted",
                  "__FK_resourceAttributes"
              FROM "resourceAttributes" FK "__FK_resourceAttributes"),
              (SELECT 
                  "__KEY_links",
                  "__FK_links"
              FROM "links" PK "__KEY_links" FK "__FK_links"),
              (SELECT 
                  "__KEY_meta",
                  "__FK_meta",
                  (SELECT 
                      "id" AS "id_u1",
                      "name" AS "name_u1",
                      "__FK_tags"
                  FROM "tags" FK "__FK_tags")
              FROM "meta" PK "__KEY_meta" FK "__FK_meta")
          FROM "data" PK "__KEY_data" FK "__FK_data"),
          (SELECT 
              "__KEY_links_u0",
              "__FK_links_u0",
              (SELECT 
                  "href" AS "href_u4",
                  "__FK_next"
              FROM "next" FK "__FK_next")
          FROM "links" PK "__KEY_links_u0" FK "__FK_links_u0")
      FROM JSON (wrap on) "root" PK "__KEY_root"
      WITH CONNECTION (  
          URL "https://$(vu_tenant_fqdn)/api/v1/items?$(vParams)"
      );


      [Apps]:
      Load
          '$(vTenantID)' AS TenantID,
          [name_u0] as AppName,
          // [resourceCustomAttributes],
          // [resourceUpdatedAt],
          If([resourceType]='app','QS','QV') AS AppType,
          [resourceId] as AppID,
          Timestamp(Timestamp([resourceCreatedAt]) + $(vReloadTimeDiffFromGMT)) as AppCreatedTime,
          // [id_u0] as [id_u0],
          // [createdAt],
          Timestamp(Timestamp([updatedAt]) + $(vReloadTimeDiffFromGMT)) as AppUpdatedTime,
          [creatorId] as AppCreatorID,
          [updaterId] as AppUpdaterID,
          // [tenantId],
          [isFavorited_u0] as AppIsFavorited,
          [description_u0] as AppDescription
      Resident RestConnectorMasterTable
      Where not IsNull([__FK_data]);

      AppDetails:
      Load	
          // [_resourcetype],
          // [createdDate],
          // [description],
          // [dynamicColor],
          If([published]='True',1,0) as AppIsDistributed,
          If([published]='True' and _resourcetype = 'app','[Qlik Sense Enterprise Client-Managed]',
          If([published]='True' and _resourcetype = 'qvapp','[QlikView Publisher]',
          If(Len([ownerId])>4,[ownerId],'[Unknown]'))) as AppOwnerID,
          [hasSectionAccess] as AppHasSectionAccess,
          [id] as AppID,
          Timestamp(Timestamp([lastReloadTime]) + $(vReloadTimeDiffFromGMT)) as AppLastReloadTime,
          Timestamp([lastReloadTime]) as AppLastReloadTimeLocalServerTime,
          // [modifiedDate],
          // [name],
          [originAppId] as AppOriginalID,
          // [ownerId],
  //         [published] as AppPublished, // Only relevant for apps distributed from QSEoW
  		  Timestamp(Timestamp([publishTime]) + $(vReloadTimeDiffFromGMT)) as AppPublishedTime,
          If(ApplyMap('AllSpacesMap',spaceId)<>1,
              If(Len(ApplyMap('Map_UserID_$(vPersonalUserField)',ownerId))>0,
                  'Personal - ' & ApplyMap('Map_UserID_$(vPersonalUserField)',ownerId),
                  '[Staged]'
                 ),
              spaceId
              ) as SpaceID,
          // [thumbnail],
          [encrypted] as AppEncrypted,
          [__FK_resourceAttributes] & '|$(vAppLoop)|$(vTenantID)' as [_KeyTags]
      Resident RestConnectorMasterTable
      Where Not IsNull([__FK_resourceAttributes]);

      AppTags:
      Load	
          [id_u1] as [AppTagID],
          [name_u1] as [AppTag],
          [__FK_tags] & '|$(vAppLoop)|$(vTenantID)' as [_KeyTags]
      Resident RestConnectorMasterTable
      Where Not IsNull([__FK_tags]);

      NextURL:
      Load	
          [href_u4] as NextURL
      Resident RestConnectorMasterTable
      Where not IsNull([__FK_next]);

      Drop Table RestConnectorMasterTable;

      Let vParams = SubField(Peek('NextURL',0,'NextURL'),'?',-1);
      Let vNextURLRows = NoOfRows('NextURL');
      Let vAppLoop = $(vAppLoop)+1;

      Drop Table NextURL;

    Loop while $(vNextURLRows)>0;
    
	Call app_num_check; // Halt the app if too many apps and not in batch mode, as reload will exceed 3 hours
    
    Concatenate(Spaces)
    Load Distinct
        SpaceID,
        SpaceID as SpaceName,
        'Personal' as SpaceType,
        AppOwnerID as SpaceOwnerID,
        '[N/A]' as SpaceDescription,
        '[N/A]' as SpaceCreatedTime,
        '[N/A]' as SpaceCreatedBy
    Resident AppDetails
    Where WildMatch(SpaceID,'Personal - *');
    
    Set OtherSymbol = +;
    
    Concatenate(Users)
    Load 
		*,
      	'[Deleted]' 	as AppOwnerStatus,
      	'[Deleted]'  	as AppOwnerName,
      	'[Deleted]' 	as AppOwnerSubject,
      	'[Deleted]'		as AppOwnerEmail
    Inline [
    	AppOwnerID
        +
    ];
    
    AllAppsMap:
    Mapping Load Distinct
        AppID,
        1
    Resident Apps;
    
    Map_AppID_AppType:
    Mapping Load Distinct
        AppID,
        AppType
    Resident Apps;
    
    Map_AppID_TenantID: // No map yet for OEM dashboard
    Load Distinct
        AppID,
        TenantID
    Resident Apps;

    Left Join(Apps)
    Load 
    	*,
        ApplyMap('Map_UserID_AppOwnerSubject_OEM',AppOwnerID) AS _AppOwnerSubjectForOEMDash
    Resident AppDetails;

    Drop Table AppDetails;

End Sub
///$tab App Num Check
Sub app_num_check

    Let vTotalApps = NoOfRows('Apps');
    
    If $(vIncrementalQVDsAvailable) <> 1 And vu_app_metadata_initial_days_back = -1 And $(vTotalApps) > $(vMaxAppsPerReloadLimit) Then
    	// Error text is not tabbed so it logs to the output left aligned.
    	Call ThrowError('This tenant contains greater than $(vMaxAppsPerReloadLimit) apps which requires the App Analyzer to be reloaded in batch. The process is as follows:
                        
1. On the "* Optional Configuration *" tab, set the "vu_app_metadata_initial_days_back" variable to 1.
2. Reload the application.
3. Repeat steps 1 and 2 while raising the number, e.g., 1 → 7, 7 → 30, 30 → 60, 60 → 90, 90 → 180.
4. Set the "vu_app_metadata_initial_days_back" variable to -1 (this indicates all time).
5. Reload the application to complete the batch process.');    

    End If
    
End Sub
///$tab App Consumption
Sub get_consumption

    If $(vIncrementalQVDsAvailable)=1 And Not IsNull('$(vIncrementalStartTime)') Then
    	Let vMaxEndTime = Replace(Timestamp('$(vIncrementalStartTime)','YYYY-MM-DD hh:mm:ssZ'),' ','T');
    Else
    	Let vMaxEndTime = Replace(Timestamp('$(vInitialDaysBack)','YYYY-MM-DD hh:mm:ssZ'),' ','T');
    End If

    Set vParams = 'filter=(endTime ge %22$(vMaxEndTime)%22)&limit=100';
    
    Consumption: 
    Load * Inline [SessionID];
    
    Do

        Lib Connect To '$(vu_rest_connection)';

        RestConnectorMasterTable:
        SQL SELECT 
            "__KEY_root",
            (SELECT 
                "id",
                "userId",
                "sessionId",
                "appId",
                "endTime",
                "duration",
                "allotmentId",
                "capacityUsed",
                "minutesUsed",
                "licenseUsage",
                "__FK_data"
            FROM "data" FK "__FK_data"),
            (SELECT 
                "__KEY_links",
                "__FK_links",
                (SELECT 
                    "href",
                    "__FK_next"
                FROM "next" FK "__FK_next"),
                (SELECT 
                    "href" AS "href_u0",
                    "__FK_prev"
                FROM "prev" FK "__FK_prev")
            FROM "links" PK "__KEY_links" FK "__FK_links")
        FROM JSON (wrap on) "root" PK "__KEY_root"
        WITH CONNECTION (  
        URL "https://$(vu_tenant_fqdn)/api/v1/licenses/consumption?$(vParams)"
        );
        
        Concatenate(Consumption)
        Load
            [id] AS SessionID,
            [id] AS _IncrementalConsumptionGUID,
            [sessionId] AS SessionIDProxy,
            [userId] AS SessionUserID,
            [appId] AS AppID,
            [endTime] AS SessionEndTime,
            [duration] AS SessionDuration,
            Round(duration/60000) AS SessionDurationMinutes,
            [allotmentId] AS SessionAllotmentID,
            [capacityUsed] AS SessionCapacityUsed,
            [minutesUsed] AS SessionMinutesUsed,
            [licenseUsage] AS SessionLicenseUsage
        Resident RestConnectorMasterTable
        Where Not IsNull([__FK_data])
        And Len(appId)>0; // The appId field can appear null when there is an immediate disconnect after the connection -- excluding these

        NextURL:
        Load Distinct 
            [href] AS NextURL
        Resident RestConnectorMasterTable
        Where  NOT match(href,'');
        Drop Table RestConnectorMasterTable;

        Let vParams = SubField(Peek('NextURL',0,'NextURL'),'?',-1);
        Let vNextURLRows = NoOfRows('NextURL');

        Drop Table NextURL;

    Loop While $(vNextURLRows)>0;
       
    If $(vIncrementalQVDsAvailable)=1 And NoOfRows('Consumption')>0 Then 

        IncrementalConsumptionMap:
        Mapping Load Distinct
            SessionID as _IncrementalConsumptionGUID,
            1
        Resident Consumption;

        Trace Calling load_qvd on Consumption;
        Call load_qvd('Consumption')
        Trace Calling store_qvd on Consumption;
        Call store_qvd('Consumption');

    ElseIf NoOfRows('Consumption')>0 Then

        Trace Calling store_qvd on Consumption;
        Call store_qvd('Consumption');

    Else

        Set vSessions = 0;

    End If
    
End Sub
///$tab Audit Sheet Consumption
Sub get_audit_sheet_consumption

    Let vCounter = 0;
    Let vNextURL = '';
    Let vUniqueKey = Num('$(reload_start)') & '$(vTenantID)';
    
    If $(vIncrementalQVDsAvailable)=1 Then
    	Let vISO_8601_Date_Range = '&eventTime=' & Left(Date(TimeStamp('$(vIncrementalStartTime)'),'YYYY-MM-DD'),10) & 'T' & Right('0' & Timestamp('$(vIncrementalStartTime)','MM/DD/YYYY hh:mm:ss'),8) & 'Z/9999-01-01T00:00:00Z';
    Else
    	Let vISO_8601_Date_Range = '&eventTime=' & Left(Date(TimeStamp('$(vInitialDaysBack)'),'YYYY-MM-DD'),10) & 'T' & Right('0' & Timestamp('$(vInitialDaysBack)','MM/DD/YYYY hh:mm:ss'),8) & 'Z/9999-01-01T00:00:00Z';
    End If
    
    SheetConsumption: 
    Load * Inline [AppID];
                
    DO
    
        LIB Connect To '$(vu_rest_connection)';

        RestConnectorMasterTable:
        SQL SELECT 
            "__KEY_root",
            (SELECT 
                "id",
                "eventId",
                "eventTime",
                "eventType",
                "source",
                "tenantId",
                "userId",
                "__KEY_data",
                "__FK_data",
                (SELECT 
                    "appId",
                    "sheetId",
                    "sheetState",
                    "sheetTitle",
                    "__FK_data_u0"
                FROM "data" FK "__FK_data_u0"),
                (SELECT 
                    "__KEY_links",
                    "__FK_links",
                    (SELECT 
                        "Href",
                        "__FK_Self"
                    FROM "Self" FK "__FK_Self"),
                    (SELECT 
                        "href",
                        "__FK_self"
                    FROM "self" FK "__FK_self")
                FROM "links" PK "__KEY_links" FK "__FK_links")
            FROM "data" PK "__KEY_data" FK "__FK_data"),
            (SELECT 
                "Prev",
                "__KEY_links_u0",
                "__FK_links_u0",
                (SELECT 
                    "Href" AS "Href_u0",
                    "__FK_Self_u0"
                FROM "Self" FK "__FK_Self_u0"),
                (SELECT 
                    "Href" AS "Href_u1",
                    "__FK_Next"
                FROM "Next" FK "__FK_Next"),
                (SELECT 
                    "href" AS "href_u0",
                    "__FK_self_u0"
                FROM "self" FK "__FK_self_u0"),
                (SELECT 
                    "href" AS "href_u1",
                    "__FK_next"
                FROM "next" FK "__FK_next")
            FROM "links" PK "__KEY_links_u0" FK "__FK_links_u0")
        FROM JSON (wrap on) "root" PK "__KEY_root"
        WITH CONNECTION (  
            URL "https://$(vu_tenant_fqdn)/api/v1/audits?limit=100&sort=-eventTime&source=com.qlik/analytics&eventType=com.qlik.v1.analytics.analytics-app-client.sheet-view.opened$(vISO_8601_Date_Range)$(vNextURL)"
        );
                
        Concatenate(SheetConsumption)
        Load	
        	[appId] AS AppID,
            [sheetId] AS SheetConsumptionSheetID,
            [sheetState] AS SheetConsumptionState,
            [sheetTitle] AS SheetConsumptionTitle,
            [__FK_data_u0] & '|' & $(vCounter) & '|' & '$(vUniqueKey)' AS [_SheetConsumptionTempKey]
        Resident RestConnectorMasterTable
        Where Not IsNull([__FK_data_u0]);

        [SheetConsumptionTemp]:
        Load	
        	[id] AS [_IncrementalSheetConsumptionID],
            [eventId] AS [SheetConsumptionEventID],
            Date([eventTime]) AS [SheetConsumptionEventTime],
//             [eventType],
//             [source],
//             [tenantId],
            [userId] AS [SheetConsumptionUserID],
            [__KEY_data] & '|' & $(vCounter) & '|' & '$(vUniqueKey)' AS [_SheetConsumptionTempKey]
        Resident RestConnectorMasterTable
        Where Not IsNull([__FK_data]);
        
        [NextURL]:
        Load	
            [href_u1] AS NextURL
        Resident RestConnectorMasterTable
        Where Not IsNull([__FK_next]);

        Drop Table RestConnectorMasterTable;

        Let vNextURL = TextBetween(Peek('NextURL',0,'NextURL'),'&next=',Null());
        
        IF SubStringCount('$(vNextURL)','&') >= 1 Then
            Let vNextURL = TextBetween('$(vNextURL)',Null(),'&');
        END IF

        Let vNextURL = '&next=' & '$(vNextURL)';

        Let vNextURLRows = NoOfRows('NextURL');

        Drop Table NextURL;
        
        Let vCounter = $(vCounter) + 1;
        
    Loop While $(vNextURLRows)>0;
    
    Left Join (SheetConsumption)
    Load * Resident SheetConsumptionTemp;
    
    Drop Table SheetConsumptionTemp;
    Drop Field _SheetConsumptionTempKey;
    
    If $(vIncrementalQVDsAvailable)=1 And NoOfRows('SheetConsumption')>0 Then 
    
        IncrementalSheetConsumptionMap:
        Mapping Load Distinct
            _IncrementalSheetConsumptionID,
            1
        Resident SheetConsumption;

        Trace Calling load_qvd on Consumption;
        Call load_qvd('SheetConsumption')
        Trace Calling store_qvd on Consumption;
        Call store_qvd('SheetConsumption');
                
    ElseIf NoOfRows('SheetConsumption')>0 Then
    
        Trace Calling store_qvd on Consumption;
        Call store_qvd('SheetConsumption');
        
    Else
    
        Trace Calling load_qvd on Consumption;
        Set vSheetConsumptionNoNewRecords = 1;
        Call load_qvd('SheetConsumption')
        
    End if;
        
End Sub
///$tab Audit Export
Sub get_audit_export_from_app

    Let vCounter = 0;
    Let vNextURL = '';
    Let vUniqueKey = Num('$(reload_start)') & '$(vTenantID)';
    
    If $(vIncrementalQVDsAvailable)=1 Then
    	Let vISO_8601_Date_Range = '&eventTime=' & Left(Date(TimeStamp('$(vIncrementalStartTime)'),'YYYY-MM-DD'),10) & 'T' & Right('0' & Timestamp('$(vIncrementalStartTime)','MM/DD/YYYY hh:mm:ss'),8) & 'Z/9999-01-01T00:00:00Z';
    Else
    	Let vISO_8601_Date_Range = '&eventTime=' & Left(Date(TimeStamp('$(vInitialDaysBack)'),'YYYY-MM-DD'),10) & 'T' & Right('0' & Timestamp('$(vInitialDaysBack)','MM/DD/YYYY hh:mm:ss'),8) & 'Z/9999-01-01T00:00:00Z';
    End If
                
    Do
    
        LIB Connect To '$(vu_rest_connection)';

        RestConnectorMasterTable:
        SQL SELECT 
            "__KEY_root",
            (SELECT 
                "id",
                "contentType",
                "eventId",
                "eventTime",
                "eventType",
                "eventTypeVersion",
                "source",
                "tenantId",
                "userId",
                "__KEY_data",
                "__FK_data",
                (SELECT 
                    "endTime",
                    "reportId",
                    "requestId",
                    "startTime",
                    "success",
                    "templateType",
                    "traceId",
                    "version",
                    "__KEY_data_u0",
                    "__FK_data_u0",
                    (SELECT 
                        "@Value",
                        "__FK_appIds"
                    FROM "appIds" FK "__FK_appIds" ArrayValueAlias "@Value"),
                    (SELECT 
                        "@Value" AS "@Value_u0",
                        "__FK_tags"
                    FROM "tags" FK "__FK_tags" ArrayValueAlias "@Value_u0")
                FROM "data" PK "__KEY_data_u0" FK "__FK_data_u0"),
                (SELECT 
                    "__KEY_links",
                    "__FK_links",
                    (SELECT 
                        "Href",
                        "__FK_Self"
                    FROM "Self" FK "__FK_Self"),
                    (SELECT 
                        "href",
                        "__FK_self"
                    FROM "self" FK "__FK_self")
                FROM "links" PK "__KEY_links" FK "__FK_links")
            FROM "data" PK "__KEY_data" FK "__FK_data"),
            (SELECT 
                "Prev",
                "__KEY_links_u0",
                "__FK_links_u0",
                (SELECT 
                    "Href" AS "Href_u0",
                    "__FK_Self_u0"
                FROM "Self" FK "__FK_Self_u0"),
                (SELECT 
                    "Href" AS "Href_u1",
                    "__FK_Next"
                FROM "Next" FK "__FK_Next"),
                (SELECT 
                    "href" AS "href_u0",
                    "__FK_self_u0"
                FROM "self" FK "__FK_self_u0"),
                (SELECT 
                    "href" AS "href_u1",
                    "__FK_next"
                FROM "next" FK "__FK_next")
            FROM "links" PK "__KEY_links_u0" FK "__FK_links_u0")
        FROM JSON (wrap on) "root" PK "__KEY_root"
        WITH CONNECTION (
        	URL "https://$(vu_tenant_fqdn)/api/v1/audits?limit=100&sort=-eventTime&source=com.qlik/reporting-service&eventType=com.qlik.v1.reporting-service.audit$(vISO_8601_Date_Range)$(vNextURL)"
		);

        [ExportFromAppID]:
        Load	
        	[@Value] AS AppID,
            [__FK_appIds] & '|' & $(vCounter) & '|' & '$(vUniqueKey)' AS [_KeyExportFromApp]
        Resident RestConnectorMasterTable
        Where Not IsNull([__FK_appIds]);

        [ExportFromAppType]:
        Load	
        	[@Value_u0] AS [ExportFromAppType],
            [__FK_tags] & '|' & $(vCounter) & '|' & '$(vUniqueKey)' AS [_KeyExportFromApp]
        Resident RestConnectorMasterTable
        Where Not IsNull([__FK_tags])
        And [@Value_u0] = 'sense-dialog.download';

        [ExportFromApp]:
        Load	
        	Date([endTime]) AS ExportFromAppEndTime,
            [reportId] AS ExportFromAppReportID,
            [requestId] AS ExportFromAppRequestID,
            Date([startTime]) AS ExportFromAppStartTime,
            [success] AS ExportFromAppSuccessful,
            If(WildMatch([templateType],'*image*'),'Image or PDF',If(WildMatch([templateType],'*data*'),'Data','[Unknown]')) AS ExportFromAppTemplateType,
            //[traceId],
            //[version] AS ExportFromAppTemplateVersion,
            [__KEY_data_u0] & '|' & $(vCounter) & '|' & '$(vUniqueKey)' AS [_KeyExportFromApp],
            [__FK_data_u0] & '|' & $(vCounter) & '|' & '$(vUniqueKey)' AS [_KeyExportFromApp2]
        Resident RestConnectorMasterTable
        Where Not IsNull([__FK_data_u0]);
        
        [ExportFromAppMeta]:
        Load	
        	[id] AS ExportFromAppTransactionID,
            [id] AS _IncrementalExportFromAppTransactionID,
//             [contentType],
//             [eventId],
//             [eventTime],
//             [eventType],
//             [eventTypeVersion],
//             [source],
//             [tenantId],
            [userId] AS ExportFromAppUserID,
            [__KEY_data] & '|' & $(vCounter) & '|' & '$(vUniqueKey)' AS [_KeyExportFromApp2]
        Resident RestConnectorMasterTable
        Where Not IsNull([__FK_data]);
        
        [NextURL]:
        Load	
            [href_u1] AS NextURL
        Resident RestConnectorMasterTable
        Where Not IsNull([__FK_next]);

        Drop Table RestConnectorMasterTable;

        Let vNextURL = TextBetween(Peek('NextURL',0,'NextURL'),'&next=',Null());
        
        If SubStringCount('$(vNextURL)','&') >= 1 THEN
            Let vNextURL = TextBetween('$(vNextURL)',Null(),'&');
        End If

        Let vNextURL = '&next=' & '$(vNextURL)';

        Let vNextURLRows = NoOfRows('NextURL');

        Drop Table NextURL;
        
        Let vCounter = $(vCounter) + 1;
        
    Loop While $(vNextURLRows)>0;
    
    Inner Join (ExportFromApp)
    Load * Resident ExportFromAppID;
    
    Inner Join (ExportFromApp)
    Load * Resident ExportFromAppType;
    
    Inner Join (ExportFromApp)
    Load * Resident ExportFromAppMeta;
    
    Drop Tables ExportFromAppID,ExportFromAppType, ExportFromAppMeta;
    Drop Fields _KeyExportFromApp, _KeyExportFromApp2, ExportFromAppType;
    
    If $(vIncrementalExportQVDsAvailable)=1 And NoOfRows('ExportFromApp')>0 Then 
    
        IncrementalExportFromAppReportIDMap:
        Mapping Load Distinct
            _IncrementalExportFromAppTransactionID,
            1
        Resident ExportFromApp;

        Trace Calling load_qvd on ExportFromApp;
        Call load_qvd('ExportFromApp')
        Trace Calling store_qvd on ExportFromApp;
        Call store_qvd('ExportFromApp');
                
    ElseIf NoOfRows('ExportFromApp')>0 Then
    
        Trace Calling store_qvd on ExportFromApp;
        Call store_qvd('ExportFromApp');
        
    Else
    
        Trace Calling load_qvd on ExportFromApp;
        Set vAppExportNoNewRecords = 1;
        Call load_qvd('ExportFromApp')
        
    End if;
        
End Sub

///$tab Audit Large App Consumption
Sub get_audit_large_app_consumption

    Let vCounter = 0;
    Let vNextURL = '';
    Let vUniqueKey = Num('$(reload_start)') & '$(vTenantID)';
    
    If $(vIncrementalQVDsAvailable)=1 Then
    	Let vISO_8601_Date_Range = '&eventTime=' & Left(Date(TimeStamp('$(vIncrementalStartTime)'),'YYYY-MM-DD'),10) & 'T' & Right('0' & Timestamp('$(vIncrementalStartTime)','MM/DD/YYYY hh:mm:ss'),8) & 'Z/9999-01-01T00:00:00Z';
    Else
    	Let vISO_8601_Date_Range = '&eventTime=' & Left(Date(TimeStamp('$(vInitialDaysBack)'),'YYYY-MM-DD'),10) & 'T' & Right('0' & Timestamp('$(vInitialDaysBack)','MM/DD/YYYY hh:mm:ss'),8) & 'Z/9999-01-01T00:00:00Z';
    End If
                
    Do
    
        LIB Connect To '$(vu_rest_connection)';

        RestConnectorMasterTable:
        SQL SELECT 
            "__KEY_root",
            (SELECT 
                "id",
                "contentType",
                "eventId",
                "eventTime",
                "eventType",
                "eventTypeVersion",
                "source",
                "tenantId",
                "userId",
                "__KEY_data",
                "__FK_data",
                (SELECT 
                    "appId",
                    "appSizeQuotaGroup",
                    "quota",
                    "released",
                    "limit",
                    "requested",
                    "spaceId",
                    "unit",
                    "consumed",
                    "__FK_data_u0"
                FROM "data" FK "__FK_data_u0"),
                (SELECT 
                    "Self",
                    "__KEY_links",
                    "__FK_links",
                    (SELECT 
                        "href",
                        "__FK_self"
                    FROM "self" FK "__FK_self")
                FROM "links" PK "__KEY_links" FK "__FK_links")
            FROM "data" PK "__KEY_data" FK "__FK_data"),
            (SELECT 
                "__KEY_links_u0",
                "__FK_links_u0",
                (SELECT 
                    "href" AS "href_u0",
                    "__FK_self_u0"
                FROM "self" FK "__FK_self_u0"),
                (SELECT 
                    "href" AS "href_u1",
                    "__FK_next"
                FROM "next" FK "__FK_next")
            FROM "links" PK "__KEY_links_u0" FK "__FK_links_u0")
        FROM JSON (wrap on) "root" PK "__KEY_root"
        WITH CONNECTION (
        	URL "https://$(vu_tenant_fqdn)/api/v1/audits?limit=100&sort=-eventTime&source=qlik.com/qix-sessions$(vISO_8601_Date_Range)$(vNextURL)"
		);
        
        [LargeAppConsumptionDetail]:
        Load	
            [appId] AS AppID,
            [appSizeQuotaGroup] AS LargeAppConsumeQuotaGroup,
            [limit] AS LargeAppConsumeLimit,
            [requested] AS LargeAppConsumeRequested,
            [quota] AS LargeAppConsumeQuota,
            [released] AS LargeAppConsumeReleased,
            //[spaceId],
            //[unit],
            [consumed] AS LargeAppConsumeConsumed,
            [__FK_data_u0] & '|' & $(vCounter) & '|' & '$(vUniqueKey)' AS [_LargeAppConsumeKey]
        Resident RestConnectorMasterTable
        Where Not IsNull([__FK_data_u0])
        And appSizeQuotaGroup = 'interactive';

        [LargeAppConsumption]:
        Load	
            //[id],
            //[contentType],
            [eventId] AS LargeAppConsumeID,
            [eventId] AS  _IncrementalLargeAppConsumeID,
            Date([eventTime]) AS LargeAppConsumeTime,
            [eventType] AS LargeAppConsumeQuotaType,
            //[eventTypeVersion],
            //[source],
            //[tenantId],
            [userId] AS LargeAppConsumeUserID,
            [__KEY_data] & '|' & $(vCounter) & '|' & '$(vUniqueKey)' AS [_LargeAppConsumeKey]
        Resident RestConnectorMasterTable
        Where Not IsNull([__FK_data])
        And (eventType = 'com.qlik.v1.quota.released'
        Or eventType = 'com.qlik.v1.quota.consumed'
        Or eventType = 'com.qlik.v1.quota.allocation-failed');

        [NextURL]:
        Load	
        	[href_u1] AS NextURL
        Resident RestConnectorMasterTable
        Where Not IsNull([__FK_next]);

        Drop Table RestConnectorMasterTable;

        Let vNextURL = TextBetween(Peek('NextURL',0,'NextURL'),'&next=',Null());
        
        If SubStringCount('$(vNextURL)','&') >= 1 THEN
            Let vNextURL = TextBetween('$(vNextURL)',Null(),'&');
        End If

        Let vNextURL = '&next=' & '$(vNextURL)';

        Let vNextURLRows = NoOfRows('NextURL');

        Drop Table NextURL;
        
        Let vCounter = $(vCounter) + 1;
        
    Loop While $(vNextURLRows)>0;
    
    Inner Join (LargeAppConsumption)
    Load * Resident LargeAppConsumptionDetail;
    
    Drop Table LargeAppConsumptionDetail;
    Drop Field _LargeAppConsumeKey;
        
    If $(vIncrementalLargeAppsQVDsAvailable)=1 And NoOfRows('LargeAppConsumption')>0 Then 
    
        IncrementalLargeAppConsumeIDMap:
        Mapping Load Distinct
            _IncrementalLargeAppConsumeID,
            1
        Resident LargeAppConsumption;

        Trace Calling load_qvd on LargeAppConsumption;
        Call load_qvd('LargeAppConsumption')
        Trace Calling store_qvd on LargeAppConsumption;
        Call store_qvd('LargeAppConsumption');
                        
    ElseIf NoOfRows('LargeAppConsumption')>0 Then
    
        Trace Calling store_qvd on LargeAppConsumption;
        Call store_qvd('LargeAppConsumption');
                
    Else
    
        Trace Calling load_qvd on LargeAppConsumption;
        Set vAppLargeAppConsumeNoNewRecords = 1;
        Call load_qvd('LargeAppConsumption');
                
    End if;
        
End Sub

///$tab Metadata
Sub app_metadata

	AppIDs:
    Load * Inline [AppID,AppType];

    If vIncrementalQVDsAvailable = 1 then   // If incremental QVDs are available -- this is set in the "configuration" section of script
        Let loaded_app_ids = '$(vOutputQVDName(AppRAM,$(app_schema_version)))';

        LoadedAppIDs:
        Mapping Load Distinct
            AppID,
            1
        From '$(loaded_app_ids)'(qvd);
        
        If vu_app_metadata_initial_days_back = -1 Then	// All apps are set to be scanned
        
            Concatenate(AppIDs)
            Load Distinct
                AppID,
                AppType
            Resident Apps
            Where (AppLastReloadTimeLocalServerTime>=TimeStamp('$(vLastReloadTime)') or ApplyMap('LoadedAppIDs',AppID,'Not in QVD')='Not in QVD') ;

		Else	// Otherwise only load app metadata for apps that have been reloaded beyond 'vu_app_metadata_initial_days_back'
        
            Concatenate(AppIDs)
            Load Distinct
                AppID,
                AppType
            Resident Apps
            Where 
            	(AppLastReloadTimeLocalServerTime>=TimeStamp('$(vLastReloadTime)') or ApplyMap('LoadedAppIDs',AppID,'Not in QVD')='Not in QVD')
                And AppLastReloadTimeLocalServerTime>=Date(Today(1) - $(vu_app_metadata_initial_days_back))
            ;
                        
        End If

        IncrementalAppMap:
        Mapping Load Distinct
            AppID as _IncrementalGUID,
            1
        Resident AppIDs;
    Else
    	If vu_app_metadata_initial_days_back = -1  Then	// All apps are set to be scanned
        
            Concatenate(AppIDs)
            Load Distinct
                AppID,
                AppType
            Resident Apps;
            
        Else	// Otherwise only load app metadata for apps that have been reloaded beyond 'vu_app_metadata_initial_days_back'
        
            Concatenate(AppIDs)
            Load Distinct
                AppID,
                AppType
            Resident Apps
            Where AppLastReloadTimeLocalServerTime>=Date(Today(1) - $(vu_app_metadata_initial_days_back));
   
        End If
        
    End If
    
    Set ErrorMode 	= 0;
    Let vLoopTotal 	= NoOfRows('AppIDs');
    Set vLoopBatch 	= 100;
    Let vNumLoops 	= Ceil($(vLoopTotal) / $(vLoopBatch));
    Let vLoopStart 	= 0;

    Trace Batch processing $(vLoopTotal) apps in chunks of $(vLoopBatch);

    For metadataLoop = 0 to $(vNumLoops) - 1
        Let vLoopEnd = RangeMin($(vLoopStart) + $(vLoopBatch) - 1, $(vLoopTotal) - 1);

        Trace Metadata Loop $(metadataLoop) Start: $(vLoopStart) End: $(vLoopEnd);
        
        // Connect once per batch
        LIB Connect To '$(vu_rest_connection)';

        For i = $(vLoopStart) to $(vLoopEnd)
        
            Let vAppGUID = Peek('AppID',i,'AppIDs');
            Let vAppType = Peek('AppType',i,'AppIDs');
            Let vResourceType = Pick(Match('$(vAppType)','QS','QV'),'app','qvapp');

            For a=1 to 3	//  loop logic.
                Trace Working on App $(vAppGUID).;

                RestConnectorMasterTable:
                SQL SELECT 
                    "static_byte_size",
                    "has_section_access",
                    "is_direct_query_mode",
                    "__KEY_root",
                    (SELECT 
                        "cpu_time_spent_ms",
                        "peak_memory_bytes",
                        "__KEY_reload_meta",
                        "__FK_reload_meta",
                        (SELECT 
                            "logical_cores",
                            "total_memory",
                            "__FK_hardware"
                        FROM "hardware" FK "__FK_hardware")
                    FROM "reload_meta" PK "__KEY_reload_meta" FK "__FK_reload_meta"),
                    (SELECT 
                        "name",
                        "is_system",
                        "is_hidden",
                        "is_semantic",
                        "distinct_only",
                        "cardinal",
                        "total_count",
                        "is_locked",
                        "always_one_selected",
                        "is_numeric",
                        "comment",
                        "byte_size",
                        "__KEY_fields",
                        "__FK_fields",
                        (SELECT 
                            "@Value",
                            "__FK_src_tables"
                        FROM "src_tables" FK "__FK_src_tables" ArrayValueAlias "@Value"),
                        (SELECT 
                            "@Value" AS "@Value_u0",
                            "__FK_tags"
                        FROM "tags" FK "__FK_tags" ArrayValueAlias "@Value_u0")
                    FROM "fields" PK "__KEY_fields" FK "__FK_fields"),
                    (SELECT 
                        "name" AS "name_u0",
                        "is_system" AS "is_system_u0",
                        "is_semantic" AS "is_semantic_u0",
                        "is_loose",
                        "no_of_rows",
                        "no_of_fields",
                        "no_of_key_fields",
                        "comment" AS "comment_u0",
                        "byte_size" AS "byte_size_u0",
                        "__FK_tables"
                    FROM "tables" FK "__FK_tables")
                FROM JSON (wrap on) "root" PK "__KEY_root"
                WITH CONNECTION (  
                    URL "https://$(vu_tenant_fqdn)/api/v1/apps/$(vAppGUID)/data/metadata"
                );	

                If ScriptError<>12 then	// Successfully found app metadata. If ScriptError = 12, there was an issue fetching metadata

                    [AppReloadCPUMetadata]:
                    Load 
                        If(ApplyMap('Map_AppID_AppType','$(vAppGUID)')='QV','Unknown (QV App)',[cpu_time_spent_ms]) as [App Reload CPU Time (ms)],
                        If(ApplyMap('Map_AppID_AppType','$(vAppGUID)')='QV','Unknown (QV App)',[peak_memory_bytes]) AS [AppRAMPeakReload_Byte],
                        If(ApplyMap('Map_AppID_AppType','$(vAppGUID)')='QV','Unknown (QV App)',Round([peak_memory_bytes]/1073741824,0.01)) AS [AppRAMPeakReload_GB],
                        If(ApplyMap('Map_AppID_AppType','$(vAppGUID)')='QV','Unknown (QV App)',Round([peak_memory_bytes]/1048576,1)) AS [AppRAMPeakReload_MB],
                        '$(vAppGUID)' as _IncrementalGUID,
                        '$(vAppGUID)' as AppID
                    Resident RestConnectorMasterTable
                    Where not IsNull([__FK_reload_meta]);

                    [ServerHardware]:
                    Load
                        If(ApplyMap('Map_AppID_AppType','$(vAppGUID)')='QV','Unknown (QV App)',[logical_cores]) as [ServerLogicalCores],
                        If(ApplyMap('Map_AppID_AppType','$(vAppGUID)')='QV','Unknown (QV App)',[total_memory]) as [ServerTotalMemory],
                        '$(vAppGUID)' as AppID,
                        '$(vAppGUID)' as _IncrementalGUID
                    Resident RestConnectorMasterTable
                    Where not IsNull([__FK_hardware]);

                    [FieldTags]:
                    Load 
                        [@Value_u0] as [FieldTag],
                        '$(vAppGUID)' & '_' & [__FK_tags] as _KeyFields,
                        '$(vAppGUID)' as TempAppID,
                        '$(vAppGUID)' as _IncrementalGUID
                    Resident RestConnectorMasterTable
                    Where not IsNull([__FK_tags]);

                    map_synthetic_fields:
                    Mapping Load 
                        '$(vAppGUID)' & '_' & [__FK_tags] as _KeyFields,
                        Dual('Synthetic Field',1) as field_is_synthetic
                    Resident RestConnectorMasterTable
                    Where not IsNull([__FK_tags]) and WildMatch([@Value_u0],'*keypart*','*syn*')>0;  

                    [Fields]:
                    Load 	
                        [name] AS FieldName,
                        ApplyMap('map_synthetic_fields','$(vAppGUID)' & '_' & [__KEY_fields],Dual('Not Synthetic',0)) AS FieldIsSynthetic,
                        //[is_system] AS [FieldIsSystem],
                        [is_hidden] AS [FieldIsHidden],
                        [is_semantic] AS [FieldIsSemantic],
                        [distinct_only] AS [FieldDistinctOnly],
                        [cardinal] AS [FieldCardinality],
                        [total_count] AS [FieldTotalCount],
                        [is_locked] AS [FieldISLocked],
                        [always_one_selected] AS [FieldAlwaysOneSelected],
                        [is_numeric] AS [FieldIsNumeric],
                        [comment] AS [FieldComment],
                        [byte_size]/1073741824 AS [FieldSize_GB],
                        [byte_size]/1048576 AS [FieldSize_MB],
                        '$(vAppGUID)' & '_' & name AS FieldID,
                        '$(vAppGUID)' AS _IncrementalGUID,
                        '$(vAppGUID)' & '_' & [__KEY_fields] AS _KeyFields
                    Resident RestConnectorMasterTable
                    Where Not IsNull([__FK_fields]) AND [is_system]='False';

                    [FieldSourceTables]:
                    Load 	
                        [@Value] AS [FieldSourceTable],
                        '$(vAppGUID)' & '_' & [@Value] AS TableID,
                        '$(vAppGUID)' AS _IncrementalGUID,
                        '$(vAppGUID)' & '_' & [__FK_src_tables] AS _KeyFields
                    Resident RestConnectorMasterTable
                    Where Not IsNull([__FK_src_tables]);

                    [Tables]:
                    Load 
                        [name_u0] AS [TableName],
                        //[is_system_u0] AS [TableIsSystem],
                        [is_semantic_u0] AS [TableIsSemantic],
                        [is_loose] AS [TableIsLoose],
                        If([is_loose]='True',1,0) AS TableIsLooseFlag,
                        [no_of_rows] AS [TableNoOfRows],
                        [no_of_fields] AS [TableNoOfFields],	// This does not count synthetic key fields
                        [no_of_key_fields] AS [TableNoOfKeyFields],	// This does not count non-key fields
                        [no_of_fields]+If([no_of_key_fields]>0,[no_of_key_fields],0) as [Table Total # of Fields],	// Includes key and synthetic key fields 
                        [comment_u0] AS [TableComment],
                        [byte_size_u0]/1073741824 AS [TableSize_GB],
                        [byte_size_u0]/1048576 AS [TableSize_MB],
                        '$(vAppGUID)' & '_' & [name_u0] AS TableID,
                        '$(vAppGUID)' AS _IncrementalGUID,
                        '$(vAppGUID)' AS AppID
                    Resident RestConnectorMasterTable
                    Where Not IsNull([__FK_tables]) AND [is_system_u0]='False';

                    [AppRAM]:
                    Load 
                        [static_byte_size] as AppRAM_Bytes,
                        [has_section_access] as AppHasSectionAccess,
                        [is_direct_query_mode] as AppHasDirectQueryMode,
                        Round([static_byte_size]/(1024*1024*1024),0.01) as [AppRAM_GB], 
                        Round([static_byte_size]/(1024*1024),1) as [AppRAM_MB],
                        //[__KEY_root] as [__KEY_root]
                        '$(vAppGUID)' as AppID,
                        '$(vAppGUID)' as _IncrementalGUID
                    Resident RestConnectorMasterTable
                    Where not IsNull([__KEY_root]);

                    Trace $(vAppGUID) metadata fetched okay.;
                    Drop Table RestConnectorMasterTable;
                    Exit For	// We successfully fetched app metadata and can proceed onward. Woohoo!

                Else
                    Drop Table RestConnectorMasterTable;
                    Trace Script Error = 12: File $(vAppGUID) has wrong format;
                    If a<3 then	//  loop logic.
                        Trace 'Trying again...';
                    ElseIf a=3 then
                        AppEndpointsNotFound:
                        Load
                            '$(vAppGUID)' as AppID,
                            1 as AppEndpointNotFound
                        AutoGenerate(1);
                    End If
                End If
            Next a // loop for error handling

        Next i

        Let vLoopStart = $(vLoopEnd) + 1;
        
    Next metadataLoop
    
    Set ErrorMode = 1;
    
    // LOAD (Concatenate) & Store each table into QVD (for incremental loading)
    For Each table in 'AppRAM','AppReloadCPUMetadata','ServerHardware','FieldTags','Fields','FieldSourceTables','Tables'
        Trace Calling load_qvd on '$(table)';
        Call load_qvd ('$(table)')
        Trace Calling store_qvd on '$(table)';
        Call store_qvd ('$(table)')
    Next table

    Drop Field _IncrementalGUID;

    // Calculate Tables count and Island Tables
    map_num_tables:
    Mapping Load Distinct
        AppID,
        Count(TableID) as NumTables
    Resident Tables
    Group By AppID;

    Rename Table Tables to TEMP;

    Tables:
    Load Distinct
        *,
        If(ApplyMap('map_num_tables',AppID,0)>1 and [TableNoOfKeyFields]=0,Dual('Island Table',1),Dual('Not an Island',0)) as TableIsIsland
    Resident TEMP;

    Drop Table TEMP;

    Let vAppRAMSizeQuota = Peek('AppRAMSizeQuota',0,'AppRAMSizeQuotas');
    Let vAppRAMSizeThreshold = Peek('AppRAMSizeThreshold',0,'AppRAMSizeQuotas');
    Let vAppRAMPeakReloadSizeThreshold = Peek('AppRAMPeakReloadSizeThreshold',0,'AppRAMSizeQuotas');

    // CLEAN UP DATA MODEL
    Left Join(Apps)
    Load Distinct 
        *,
        If(ApplyMap('Map_AppID_AppType',AppID)='QV',Dual('Unknown (Likely QV App)',-1),(If([App Reload CPU Time (ms)]>=$(vReloadCPUTimeThreshold),Dual('Reload CPU Time Exceeded',1),Dual('Reload CPU Time OK',0)))) as AppReloadCPUTimeOverThreshold,
        If(ApplyMap('Map_AppID_AppType',AppID)='QV',Dual('Unknown (Likely QV App)',-1),(If([AppRAMPeakReload_Byte]>=$(vAppRAMPeakReloadSizeThreshold),Dual('App Peak Reload RAM Exceeded',1),Dual('App Peak Reload RAM OK',0)))) as AppPeakRAMOverThreshold
    Resident AppReloadCPUMetadata;

    Left Join(Apps)
    Load Distinct 
        *
    Resident AppRAM;

    Drop Tables AppReloadCPUMetadata, AppRAM;

    // Synthetic Tables exists at App Level
    map_app_synthetic:
    Mapping Load 
        Distinct TempAppID as AppID,
        Dual('Has Synthetic Keys',1) as AppContainsSyntheticKeys
    Resident FieldTags
    Where (FieldTag='$keypart' OR FieldTag='$syn');

    //  Synthetic Keys exist at Table Level
    Left Join(FieldSourceTables)
    Load
        If(FieldIsSynthetic>0,Dual('Synthetic Keys Present',1),Dual('No Synthetic Keys',0)) as TableContainsSyntheticKeys,
        _KeyFields
    Resident Fields;

    Drop Field TempAppID;

    // Island Tables exist at App level
    map_app_data_islands:
    Mapping Load 
        AppID,
        If(Max(TableIsIsland)>0,Dual('Has Island Table',1)) as [AppContainsDataIsland(s)]
    Resident Tables
    Where TableIsIsland=1
    Group By AppID;	// Just return one record per appID

    // Tables Record Count by App
    map_app_table_record_count:
    Mapping Load 
        AppID,
        Sum(TableNoOfRows) as [AppTableNoOfRowsMapping]
    Resident Tables
    Group By AppID;

    // Circular References
    map_app_circular_reference:
    Mapping Load 
        AppID,
        Sum(TableIsLooseFlag) as [TableIsLooseFlagSummed]
    Resident Tables
    Group by AppID;

    Drop Field TableIsLooseFlag;

    // Number of distinct fields by App
    map_app_distinct_fields:
    Mapping Load
        SubField(FieldID,'_',1) as AppID,
        Count(FieldID) as AppNumberOfDistinctFields  
    Resident Fields
    Group By SubField(FieldID,'_',1);


    // Last Reload Date Windows and Calendar
    MinMax:
    Load
        Max(AppLastReloadTime) as AppLastReloadTimeMax,
        Min(AppLastReloadTime) as AppLastReloadTimeMin
    Resident Apps
    Where Num(Date(AppLastReloadTime))>0;

    Let vAppLastReloadTimeMax = YearStart(FieldValue('AppLastReloadTimeMax',1));
    Let vAppLastReloadTimeMin = YearStart(FieldValue('AppLastReloadTimeMin',1));
    Let vMaxYear = Num(Year(Date('$(vAppLastReloadTimeMax)')))+1;
    Let vMinYear = Num(Year(Date('$(vAppLastReloadTimeMin)')));
    Drop Table MinMax;

    AppLastReloadedBuckets:
    Load 
        Dual(
            Date(AddMonths('$(vAppLastReloadTimeMin)',(RecNo()*$(vu_months_in_reload_interval))-$(vu_months_in_reload_interval))) 
            & ' -> ' & AddMonths(Date('$(vAppLastReloadTimeMin)'),RecNo()*$(vu_months_in_reload_interval))
            ,Num(AddMonths('$(vAppLastReloadTimeMin)',(RecNo()*$(vu_months_in_reload_interval))-$(vu_months_in_reload_interval)))) 
            as AppLastReloadedBucket,
        Date(AddMonths('$(vAppLastReloadTimeMin)',(RecNo()*$(vu_months_in_reload_interval))-$(vu_months_in_reload_interval))) as FromDate,
        AddMonths(Date('$(vAppLastReloadTimeMin)'),RecNo()*$(vu_months_in_reload_interval)) as ToDate
    AutoGenerate ($(vMaxYear) - $(vMinYear))*(Ceil(12/$(vu_months_in_reload_interval)));

    IntervalMatch (AppLastReloadTime) 
    Left Join
    Load Distinct FromDate, ToDate 
    Resident AppLastReloadedBuckets;

    Left Join (Apps)
    Load Distinct
        AppLastReloadedBucket,
        AppLastReloadTime
    Resident AppLastReloadedBuckets;

    Drop Table AppLastReloadedBuckets;

    Rename Table Apps to TEMP;
    Rename Field AppLastReloadedBucket to AppLastReloadedBucketTemp;

    // Add and update fields in the Apps table
    Apps:
    Load Distinct
        *,
        ApplyMap('map_num_tables',AppID,0) as AppNoOfTables,
        ApplyMap('map_app_synthetic',AppID,Dual('No Synthetic Keys',0)) as AppContainsSyntheticKeys,
        ApplyMap('map_app_data_islands',AppID,Dual('No Data Islands',0)) as [AppContainsDataIsland(s)],
        ApplyMap('map_app_distinct_fields',AppID,0) as AppNumberOfDistinctFields,
        ApplyMap('map_app_table_record_count',AppID,0) as AppTableNoOfRows,
        If(ApplyMap('map_app_circular_reference',AppID,0)<1,Dual('No Circular Reference(s)',0),Dual('Has Circular Reference(s)',1)) as [AppContainsCircularReference(s)],
        If(ApplyMap('map_app_table_record_count',AppID,0)>=$(vAppRecordCountThreshold),Dual('App Record Count Exceeded',1),Dual('App Record Count OK',0)) as AppTableNoOfRowsOverThreshold,
        If(ApplyMap('map_app_distinct_fields',AppID,0)>=$(vNoOfFields),Dual('Field Count Exceeded',1),Dual('Field Count OK',0)) as AppNumberOfDistinctFieldsOverThreshold,
        If(Len(AppLastReloadedBucketTemp)>1,AppLastReloadedBucketTemp,Dual('App Has Not Been Reloaded (On June ' & Chr(39) & '18+ or on a Qlik tenant)',-1)) as AppLastReloadedBucket,
        If(AppRAM_Bytes>=$(vAppRAMSizeThreshold),Dual('App RAM Exceeded',1),Dual('App RAM OK',0)) as AppRAMOverThreshold,
        If('$(vAppRAMSizeQuota)'<>'Unlimited',AppRAM_Bytes/'$(vAppRAMSizeQuota)','Unlimited') as AppRAMPercentToQuota,
        If('$(vAppRAMSizeQuota)'<>'Unlimited' and (AppRAM_Bytes/'$(vAppRAMSizeQuota)') >= .6,Pow((AppRAM_Bytes/'$(vAppRAMSizeQuota)')+1.2,7),Null()) as _AppRAMPercentToQuotaColor,
        AppRAMPeakReload_Byte/'$(vAppRAMPeakReloadSizeQuota)' as AppRAMPeakReloadPercentToQuota,
        If(AppRAMPeakReload_Byte/'$(vAppRAMPeakReloadSizeQuota)' >= .6,Pow((AppRAMPeakReload_Byte/'$(vAppRAMPeakReloadSizeQuota)')+1.2,7),Null()) as _AppRAMPeakReloadPercentToQuotaColor
    Resident TEMP;

    Drop Table TEMP;
    Drop Field AppLastReloadedBucketTemp;

    // Handling for 'unlimited' quotas
    If '$(vAppRAMSizeQuota)'='Unlimited' then
        MaxAppPercentToQuota:
        Load
            1 as MaxAppRAMPercentToQuota,
            Max(AppRAMPeakReloadPercentToQuota) as MaxAppRAMPeakReloadPercentToQuota
        Resident Apps;
    Else
        MaxAppPercentToQuota:
        Load
            Max(AppRAMPercentToQuota) as MaxAppRAMPercentToQuota,
            Max(AppRAMPeakReloadPercentToQuota) as MaxAppRAMPeakReloadPercentToQuota
        Resident Apps;
    End If

    Let vAppRAMSizeQuota = '';
    Let vAppRAMSizeThreshold = '';
    Let vAppRAMPeakReloadSizeThreshold = '';

    Let app_count = Num(NoOfRows('Apps'),'#,##0'); // This is the actual number of Apps.

    // create buckets for app RAM percent to quota
    Let vMaxAppRAMPercentToQuota = Peek('MaxAppRAMPercentToQuota',0,'MaxAppPercentToQuota');

    Concatenate (Apps)
    Load
        (IterNo()-1) * .1 + .01 as AppRAMPercentToQuota
    AutoGenerate(1)
    While ((IterNo()-1) * .1 + .01) <= $(vMaxAppRAMPercentToQuota) or ((IterNo()-1) * .1 + .01) <= 1;


    // create buckets for app RAM reload peak percent to quota
    Let vMaxAppRAMPeakReloadPercentToQuota = Peek('MaxAppRAMPeakReloadPercentToQuota',0,'MaxAppPercentToQuota');

    DROP TABLE MaxAppPercentToQuota;

    Concatenate (Apps)
    Load
        (IterNo()-1) * .1 + .01 as AppRAMPeakReloadPercentToQuota
    AutoGenerate(1)
    While ((IterNo()-1) * .1 + .01) <= $(vMaxAppRAMPeakReloadPercentToQuota) or ((IterNo()-1) * .1 + .01) <= 1;

    // Create mapping tables for FieldNameUnique dualing with App GUIDs
    map_key_fields_table_id:
    Mapping Load Distinct
      [_KeyFields],
      TableID
    Resident FieldSourceTables;

    map_table_id_app_id:
    Mapping Load Distinct
      TableID,
      AppID
    Resident Tables;

    // Update fields table
    Rename Table Fields to TEMP;

    Fields:
    Load
        *,
        If([FieldTotalCount]>=$(vFieldValueCountThreshold),Dual('Field Total Count Exceeded',1),Dual('Field Total Count OK',0)) as FieldValueCountOverThreshold,
        If([FieldCardinality]>=$(vFieldCardinalityThreshold),Dual('Field Cardinality Exceeded',1),Dual('Field Cardinality OK',0)) as FieldCardinalityOverThreshold
    Resident TEMP;

    Drop Table TEMP;

    // Update Tables table
    Rename Table Tables to TEMP;

    Tables:
    Load
        *,
        If([TableNoOfRows]>=$(vTableRecordCountThreshold),Dual('Table Rows Exceeded',1),Dual('Table Rows OK',0)) as TableNoOfRowsOverThreshold
    Resident TEMP;

    Drop Table TEMP;

    Drop Table AppIDs;
    
    Set OtherSymbol = +;
    
    Concatenate(Apps)
    Load 
		*,
        '$(vTenantID)'  AS TenantID,
      	'[Deleted]' 	AS AppName
    Inline [
    	AppID
        +
    ];

    Trace Metadata for $(app_count) apps has been assembled!; // Note the actual number of rows in the final table is higher than the number of apps due to AppRAMPercentToQuota
  
End Sub
///$tab Incremental QVD
// For loading a table from QVD ///////////////////
Sub load_qvd (table)

    Let qvd_name = '$(vOutputQVDName($(table),$(app_schema_version)))';
    If $(vIncrementalQVDsAvailable)=1 then

      Trace Looking to load: $(qvd_name).;
      Let file_size = If(IsNull(FileSize('$(qvd_name)')),0,FileSize('$(qvd_name)'));

      If file_size > 0 then
          Trace File size is $(file_size) bytes;
          Trace Fetching data from: $(qvd_name);
          Trace $(table);
          
          If '$(table)' = 'Consumption' Then
          
              $(table):
              Load Distinct 
                  * 
              From '$(qvd_name)'(qvd)
              Where ApplyMap('IncrementalConsumptionMap',_IncrementalConsumptionGUID)<>1
              And SessionEndTime >= Date('$(vMaxSessionAge)');
              
          Elseif '$(table)' = 'SheetConsumption' Then
          
              If $(vSheetConsumptionNoNewRecords)<>1 Then
          
                  $(table):
                  Load Distinct 
                      * 
                  From '$(qvd_name)'(qvd)
                  Where ApplyMap('IncrementalSheetConsumptionMap',_IncrementalSheetConsumptionID)<>1
                  And SheetConsumptionEventTime >= Date('$(vMaxSessionAge)');
                  
              Else
              
                  $(table):
                  Load Distinct 
                      * 
                  From '$(qvd_name)'(qvd)
                  Where SheetConsumptionEventTime >= Date('$(vMaxSessionAge)');
                  
              End If
              
          Elseif '$(table)' = 'ExportFromApp' Then
          
              If $(vAppExportNoNewRecords)<>1 Then
          
                  $(table):
                  Load Distinct 
                      * 
                  From '$(qvd_name)'(qvd)
                  Where ApplyMap('IncrementalExportFromAppReportIDMap',_IncrementalExportFromAppTransactionID)<>1
                  And ExportFromAppStartTime >= Date('$(vMaxSessionAge)');
                  
              Else
              
                  $(table):
                  Load Distinct 
                      * 
                  From '$(qvd_name)'(qvd)
                  Where ExportFromAppStartTime >= Date('$(vMaxSessionAge)');
                  
              End If
              
          Elseif '$(table)' = 'LargeAppConsumption' Then
          
              If $(vAppLargeAppConsumeNoNewRecords)<>1 Then
          
                  $(table):
                  Load Distinct 
                      * 
                  From '$(qvd_name)'(qvd)
                  Where ApplyMap('IncrementalLargeAppConsumeIDMap',_IncrementalLargeAppConsumeID)<>1
                  And LargeAppConsumeTime >= Date('$(vMaxSessionAge)');
                  
              Else
              
                  $(table):
                  Load Distinct 
                      * 
                  From '$(qvd_name)'(qvd)
                  Where LargeAppConsumeTime >= Date('$(vMaxSessionAge)');
                  
              End If
          
          Else
          
              $(table):
              Load Distinct 
                  * 
              From '$(qvd_name)'(qvd)
              Where ApplyMap('IncrementalAppMap',_IncrementalGUID)<>1
              and ApplyMap('AllAppsMap',_IncrementalGUID)=1;
          
          End If

      Else
          Trace Could not find file: $(qvd_name).;
      End If

    End If

End Sub


// For storing a table to QVD ///////////////////
Sub store_qvd (table)
    Let qvd_name = '$(vOutputQVDName($(table),$(app_schema_version)))';
    Trace Storing $(qvd_name).;
    Store $(table) into '$(qvd_name)' (qvd);
    Let file_size_$(table) = FileSize('$(qvd_name)');
    Trace $(qvd_name) stored!;
End Sub

// Store QVDs of high-level app metadata on every reload to track growth over time ///////////////////
Sub store_app_meta_rolling

	app_analyzer_rolling:
    Load Distinct
        AppID,
        [App Reload CPU Time (ms)] as [App Reload CPU Time (ms) - Rolling],
        [AppRAM_GB] as [AppRAM_GB - Rolling],
        [AppRAM_MB] as [AppRAM_MB - Rolling],
        [AppRAMPeakReload_GB] as [AppRAMPeakReload_GB - Rolling],
        [AppRAMPeakReload_MB] as [AppRAMPeakReload_MB - Rolling],
        [AppNoOfTables] as [AppNoOfTables - Rolling],
        [AppNumberOfDistinctFields] as [AppNumberOfDistinctFields - Rolling],
        [AppTableNoOfRows] as [AppTableNoOfRows - Rolling],
        Date(Floor(Today(1))) as AppRollingTimestamp,
        Date(Floor(Today(1))) & '|' & AppID as _app_meta_key
     Resident Apps
     Where Len(AppID)>0;
     
     If $(vRollingQVDsAvailable) then
    	Trace Fetching data from: app_analyzer_rolling.qvd;
        
        app_analyzer_rolling:
    	Load
            *
        From $(vRollingQVDName) (qvd)
        Where ApplyMap('AllAppsMap',AppID)=1
        and Today(1)-Date(AppRollingTimestamp)<=$(vu_track_app_meta_retention)
        and not Exists(_app_meta_key);
    End If
     
     Trace Storing app_analyzer_rolling.qvd;
     Store app_analyzer_rolling into $(vRollingQVDName) (qvd);
     Let file_size_app_analyzer_rolling = FileSize('$(vRollingQVDName)');
     Trace app_analyzer_rolling.qvd stored!;
     
End Sub
///$tab Multi-Tenant
Sub write_tenant_qvds(location, sub_dir, name, is_parent)
    Trace Storing QlikMetaCollection QVDs.;

    Let location = If(Right('$(location)',1)='/',Left('$(location)',Len('$(location)')-1),'$(location)');

    If $(is_parent)=0 then
        Let vFullLocation = '$(location)/QlikMetaCollection/Tenants/$(vTenantID)/$(sub_dir)/$(name)';
    Else
        Let vFullLocation = '$(location)/QlikMetaCollection/CompiledTenants/$(sub_dir)/$(name)';
    End if

    For i = 0 to NoOfTables()-1
        Let vTableName = TableName($(i));
        Trace Storing $(vTableName).;
        Store $(vTableName) Into [$(vFullLocation)/$(vTableName).qvd](qvd);
        Trace $(vTableName) stored!;
    Next i
  
End Sub

Sub load_multi_tenant_qvds(location, sub_dir, name)

	Let vDirLocation = If(Right('$(location)',1)='/',Left('$(location)',Len('$(location)')-1),'$(location)');
    Let vAnyFileFound = 0;

	Let vTenants = 1;
	For Each Dir in DirList('$(vDirLocation)/QlikMetaCollection/Tenants/')

        Let vFolder = '$(Dir)$(sub_dir)/$(name)/';
        Let vTenant = TextBetween('$(vFolder)','$(vDirLocation)/','/$(sub_dir)/');
        Trace --------------------;
        Trace Looking to load data for Tenant: $(vTenant);
        Trace --------------------;

        Let vTenantFileFound = 0;
        For Each file in FileList('$(vFolder)')
            If WildMatch('$(file)','*.qvd') THEN
                Let vAnyFileFound = 1;
                Let vTenantFileFound = 1;

                Let vTableName = TextBetween(Subfield('$(file)','/',-1),Null(),'.qvd');
                "$(vTableName)":
                Load Distinct
                    *
                From [$(file)](qvd);
            End If
        Next file

        If $(vTenantFileFound) then
            Trace Completed loading QVDs for Tenant: $(vTenant);
            Let vTenants = $(vTenants) + 1;
        Else
          	Trace No QVDs were found for Tenant: $(vTenant);
        End If
              
    Next Dir
    
    Let vTenants = $(vTenants) - 1;
    
    If $(vAnyFileFound)>0 then
        Trace --------------------;
        Trace Successfully loaded data from $(vTenants) Tenants!;
        Trace --------------------;
    Else
        Trace --------------------;
        Trace No QVDs were Found! Confirm that this directory is the parent directory of "QlikMetaCollection".;
        Trace --------------------;
    End If


End Sub
///$tab Transform
Sub transform

	// build maps for OEM dashboard

	Rename Table Map_UserID_AppOwnerName To TEMP;

	Map_UserID_AppOwnerName:
    Mapping Load Distinct
    	*
    Resident TEMP;
    
    Drop Table TEMP;
    
	Rename Table Map_UserID_AppOwnerSubject To TEMP;

	Map_UserID_AppOwnerSubject:
    Mapping Load Distinct
    	*
    Resident TEMP;
    
    Drop Table TEMP;
    
	Rename Table Map_OAuthClientName To TEMP;

	Map_OAuthClientName:
    Mapping Load Distinct
    	*
    Resident TEMP;
    
    Drop Table TEMP;
    
	Rename Table Map_AppID_TenantID To TEMP;

	Map_AppID_TenantID:
    Mapping Load Distinct
    	*
    Resident TEMP;
    
    Drop Table TEMP;
    
    // Drop spaces without any apps
    Rename Table Spaces To TEMP;

    Spaces:
    Left Keep (Apps)
    Load * Resident TEMP;

    Drop Table TEMP;
    
    Rename Table ExportFromApp To TEMP;
    Rename Field ExportFromAppEndTime To ExportFromAppEndTimeTemp;
    Rename Field ExportFromAppStartTime To ExportFromAppStartTimeTemp;
    
    ExportFromApp:
    LOAD
    	*,
        ExportFromAppUserID as SessionUserIDTemp, // for intervalmatch of exports,
        Date(Timestamp(ExportFromAppEndTimeTemp) + $(vReloadTimeDiffFromGMT),'YYYY-MM-DD hh:mm:ss') as ExportFromAppEndTime,
        Date(Timestamp(ExportFromAppStartTimeTemp) + $(vReloadTimeDiffFromGMT),'YYYY-MM-DD hh:mm:ss') as ExportFromAppStartTime
    Resident TEMP;
    
    Drop Table TEMP;
    Drop Fields ExportFromAppEndTimeTemp, ExportFromAppStartTimeTemp;
    
    Rename Table Consumption to TEMP;
    Rename Field SessionEndTime to SessionEndTimeTemp; // changes casting to new field
    
    [Consumption]:
    Load
    	*,
        AutoNumber(SessionStartTime & '|' & SessionEndTime,'ConsumptionConcurrency') as _ConsumptionExecutionConcurrencyKey,
        Date(Floor(SessionStartTime)) as SessionStartTimeDate,
        Date(Floor(SessionStartTime,1/24)) as SessionStartTimeDateHourFloored,
        Hour(SessionStartTime) as SessionHour,
        Minute(SessionStartTime) as SessionMinute,
        Dual(Text(Time(SessionStartTime,'h TT')),Hour(SessionStartTime)) as SessionHourAMPM,
        If(Date(Floor(SessionStartTime))<$(vLast90Days),'True','False') as AppNotAccessedInOver90Days,
        If(Date(Floor(SessionStartTime))<$(vLast60Days),'True','False') as AppNotAccessedInOver60Days,
        If(Date(Floor(SessionStartTime))<$(vLast30Days),'True','False') as AppNotAccessedInOver30Days
    WHERE SessionStartTime>=Date('$(vInitialDaysBack)') 
    ;
    Load
        *,
        If(ApplyMap('Map_OAuthClientName',SessionUserName & '|' & ApplyMap('Map_AppID_TenantID',AppID,Null()))=1,'True','False') as SessionUserIsOAuthClient,
        Timestamp(SessionEndTime-SessionDurationInterval) as SessionStartTime
    ;
    Load
//         SessionAllotmentID,
        AppID,
        SessionCapacityUsed,
        SessionDuration as SessionDurationMS,
        Interval(Round(SessionDuration/1000)/(60*60*24),'hh:mm:ss') as SessionDurationInterval,
        //Interval(SessionDurationMinutes/60/24) AS SessionDurationInterval,
        SessionDurationMinutes,
        Date(Timestamp(SessionEndTimeTemp) + $(vReloadTimeDiffFromGMT),'YYYY-MM-DD hh:mm:ss') as SessionEndTime,
        Date(Floor(Timestamp(Timestamp(SessionEndTimeTemp) + $(vReloadTimeDiffFromGMT)))) as SessionEndTimeDate,
//         SessionID,
//         SessionIDProxy,
        AutoNumber(SessionID & '|' & AppID,'Session') AS SessionID, // SessionID is the proxy session which needs to combine with the AppID for a pseudo app session ID. The ID field is generated from mongo and can't be used
        SessionMinutesUsed,
        If(WildMatch(SessionUserID,'qau-*'),'[Anonymous User]',ApplyMap('Map_UserID_AppOwnerName',SessionUserID,'[Deleted]')) as SessionUserName,
        If(WildMatch(SessionUserID,'qau-*'),'[Anonymous User]',ApplyMap('Map_UserID_AppOwnerSubject',SessionUserID,'[Deleted]')) as SessionUserSubject,
        SessionUserID,
        SessionUserID AS SessionUserIDTemp,
        SessionLicenseUsage
    Resident TEMP;
    
    Drop Field SessionDuration;
    
    Drop Table TEMP;
    
    Rename Table SheetConsumption To TEMP;
    
    Max_SheetAccessDate:
    Mapping Load
        SheetConsumptionSheetID & '|' & AppID as _Key_Max_SheetAccessDate,
        Max(SheetConsumptionEventTime) as SheetConsumptionSheetIDMaxTime
    Resident TEMP
    Where Date(SheetConsumptionEventTime + $(vReloadTimeDiffFromGMT))>=Date('$(vInitialDaysBack)')
    Group By SheetConsumptionSheetID, AppID;
    
    Map_SheetTitle:
    Mapping Load
        SheetConsumptionSheetID & '|' & AppID as _Key_Max_SheetAccessDate,
        If(Len(Trim(SheetConsumptionTitle))>0,SheetConsumptionTitle,If(Date(SheetConsumptionEventTime)>=Date('$(vSheetTitleAddedDate)'),'<Empty>','<Not Available>')) AS SheetConsumptionTitle
    Resident TEMP
    Where Date(SheetConsumptionEventTime + $(vReloadTimeDiffFromGMT))>=Date('$(vInitialDaysBack)')
    AND ApplyMap('Max_SheetAccessDate',SheetConsumptionSheetID & '|' & AppID)=SheetConsumptionEventTime;
    
    SheetConsumption:
    Load
        AppID,
        SheetConsumptionSheetID,
        SheetConsumptionState,
        If(Date(SheetConsumptionEventTime)>=Date('$(vSheetTitleAddedDate)'),ApplyMap('Map_SheetTitle',SheetConsumptionSheetID & '|' & AppID),'<Not Available>') as SheetConsumptionTitle,
        If(Len(Trim(SheetConsumptionTitle))>0,SheetConsumptionTitle,If(Date(SheetConsumptionEventTime)>=Date('$(vSheetTitleAddedDate)'),'<Empty>','<Not Available>')) as SheetConsumptionTitleHistorical,
        SheetConsumptionEventID,
        Timestamp(Timestamp(SheetConsumptionEventTime) + $(vReloadTimeDiffFromGMT)) as SheetConsumptionEventTime,
        SheetConsumptionUserID,
        SheetConsumptionUserID as SessionUserID,
        If(WildMatch(SheetConsumptionUserID,'qau-*'),'[Anonymous User]',ApplyMap('Map_UserID_AppOwnerName',SheetConsumptionUserID,'[Deleted]')) as SheetConsumptionUserName,
        If(WildMatch(SheetConsumptionUserID,'qau-*'),'[Anonymous User]',ApplyMap('Map_UserID_AppOwnerSubject',SheetConsumptionUserID,'[Deleted]')) as SheetConsumptionUserSubject
    Resident TEMP
    Where Date(SheetConsumptionEventTime + $(vReloadTimeDiffFromGMT))>=Date('$(vInitialDaysBack)');

	Drop Table TEMP;
    
    If Not ($(vu_multi_tenant_enabled)=1 And $(vu_is_parent_app)=1) And NoOfRows('Consumption')>0 THEN
    
    	////////////////////////////////
    	// Calculating app concurrency
        ////////////////////////////////
        
        SessionMinMaxDates:
        LOAD
            Floor(Min("SessionStartTime"),1/24/60) AS "Session Start Time Min",
            Ceil(Max("SessionEndTime"),1/24/60) AS "Session End Time Max"
        RESIDENT Consumption;

        Let vConsumptionMinDate = Peek('Session Start Time Min',0,'SessionMinMaxDates');
        Let vConsumptionMaxDate = Peek('Session End Time Max',0,'SessionMinMaxDates');
        
        DROP TABLE SessionMinMaxDates;

        Let vMinutes = Ceil(($(vConsumptionMaxDate)-$(vConsumptionMinDate))*24*(60/$(vConsumptionMinutes)));
        
        ConsumptionMinutesTemp:
        Load Distinct
            TimeStamp(Floor(Date($(vConsumptionMinDate)+((1/24/(60/$(vConsumptionMinutes)))*RowNo())),1/24/60)) as ConsumptionConcurrencyMinute
        Autogenerate $(vMinutes);
                        
        Left Join
        IntervalMatch (ConsumptionConcurrencyMinute) 
        Load 
            SessionStartTime,
            SessionEndTime
        Resident Consumption;
        
        ConumptionConcurrencyMinutes:
        Left Keep (Consumption)
        Load
            Timestamp(ConsumptionConcurrencyMinute,'YYYY-MM-DD hh:mm:ss') as ConsumptionConcurrencyMinute,
        	AutoNumber(SessionStartTime&'|'&SessionEndTime,'ConsumptionConcurrency') as _ConsumptionExecutionConcurrencyKey
        Resident ConsumptionMinutesTemp;

        Drop Table ConsumptionMinutesTemp;
                
        ////////////////////////////////
    	// Merging sheet usage to sessions by AppID, UserID, and Timestamp into single table
        ////////////////////////////////
        
        Left Join(Consumption)
        IntervalMatch(SheetConsumptionEventTime, AppID, SessionUserID)
        LOAD         	
        	SessionStartTime,
            SessionEndTime,
            AppID,
            SessionUserID
        Resident Consumption;
        
        Left Join (Consumption)
        Load *
        Resident SheetConsumption;

        Drop Table SheetConsumption;

		// Split off into two tables linking on SessionID
        
        SheetConsumptionTemp:
        Load Distinct
            *,
            If(Peek(SessionID)<>SessionID,1,Peek(SheetConsumptionOrder)+1) as SheetConsumptionOrder
            ;
        Load Distinct
            SessionID,
            SheetConsumptionSheetID,
            SheetConsumptionState,
            SheetConsumptionTitle,
            SheetConsumptionTitleHistorical,
            SheetConsumptionEventID,
            TimeStamp(SheetConsumptionEventTime,'YYYY-MM-DD hh:mm:ss') as SheetConsumptionEventTime,
            SheetConsumptionUserID,
            SheetConsumptionUserName,
            SheetConsumptionUserSubject,
            If(Date(Floor(SheetConsumptionEventTime))<$(vLast90Days),'True','False') as SheetNotAccessedInOver90Days,
            If(Date(Floor(SheetConsumptionEventTime))<$(vLast60Days),'True','False') as SheetNotAccessedInOver60Days,
            If(Date(Floor(SheetConsumptionEventTime))<$(vLast30Days),'True','False') as SheetNotAccessedInOver30Days,
            SessionEndTime AS SessionEndTimeTemp,
            'https://' & If(Len('$(vu_tenant_alias)')>0,'$(vu_tenant_alias)','$(vu_tenant_fqdn)') & '/sense/app/' & AppID & '/sheet/' & SheetConsumptionSheetID AS SheetConsumptionLink
        Resident Consumption
        Where Len(SheetConsumptionSheetID)>0
        Order By SessionID Asc, SheetConsumptionEventTime Asc;

        SheetConsumption:
        NoConcatenate
        Load 
        	*,
            If(Peek(SessionID)<>SessionID,
            	Interval(SessionEndTimeTemp-SheetConsumptionEventTime),
                Interval(Peek(SheetConsumptionEventTime)-SheetConsumptionEventTime))
			AS SheetConsumptionOrderDuration,
            If(Peek(SessionID)<>SessionID,
            	TimeStamp(SessionEndTimeTemp,'YYYY-MM-DD hh:mm:ss'),
                TimeStamp(Peek(SheetConsumptionEventTime),'YYYY-MM-DD hh:mm:ss'))
			AS SheetConsumptionEventEndTime
            ;
        Load 
        	*
        Resident SheetConsumptionTemp
        Order By SessionID Desc, SheetConsumptionEventTime Desc;
        
        Drop Table SheetConsumptionTemp;
        
        ////////////////////////////////
    	// Merging app exports to sheet consumption by AppID, UserID, and Timestamp into single table
        ////////////////////////////////
        
        Left Join(Consumption)
        IntervalMatch(ExportFromAppStartTime, AppID, SessionUserIDTemp)
        Load         	
        	SessionStartTime,
            SessionEndTime,
            AppID,
            SessionUserIDTemp
        Resident Consumption;
        
        Left Join (Consumption)
        Load *
        Resident ExportFromApp;

        Drop Table ExportFromApp;
        
        ExportFromApp:
        Load Distinct
        	SessionID,
        	'True' AS SessionHadExport,
            ExportFromAppEndTime,
            ExportFromAppReportID,
            ExportFromAppRequestID,
            ExportFromAppStartTime,
            ExportFromAppSuccessful,
            ExportFromAppTemplateType,
            ExportFromAppTransactionID
            //ExportFromAppUserID
        Resident Consumption
        Where Len(ExportFromAppStartTime)>0;
        
        ////////////////////////////////
    	// Strip back consumption after removing sheet usage and exports
        ////////////////////////////////
        
        Rename Table Consumption To TEMP;
        Drop Field SessionEndTimeTemp;

        Consumption:
        Load Distinct
            _ConsumptionExecutionConcurrencyKey,
            SessionStartTimeDate,
            SessionHour,
            SessionMinute,
            SessionHourAMPM,
            SessionStartTimeDateHourFloored,
            AppNotAccessedInOver90Days,
            AppNotAccessedInOver60Days,
            AppNotAccessedInOver30Days,
            SessionUserIsOAuthClient,
            SessionStartTime,
            AppID,
            SessionCapacityUsed,
            SessionDurationMS,
            SessionDurationInterval,
            SessionDurationMinutes,
            SessionEndTime,
            SessionEndTimeDate,
            SessionID,
            SessionMinutesUsed,
            SessionUserName,
            SessionUserSubject,
            SessionUserID,
            SessionLicenseUsage
        Resident TEMP;

        Drop Table TEMP;
        
    	////////////////////////////////
    	// Transforming large app consumption data
        ////////////////////////////////
        
        If NoOfRows('LargeAppConsumption')>0 Then
        	Set vAppContainsLargeAppConsumption = 1;
            
            ///// Peel off denial events into a separate table
            LargeAppConsumptionDenials:
            Load
                AppID,
                LargeAppConsumeQuotaGroup AS LargeAppConsumeDenialQuotaGroup,
                LargeAppConsumeRequested AS LargeAppConsumeDenialRequested,
                LargeAppConsumeRequested AS LargeAppConsumeDenialAmount,
                LargeAppConsumeLimit AS LargeAppConsumeDenialLimit,
                LargeAppConsumeUserID AS LargeAppConsumeDenialUserID,
                Date(Timestamp(LargeAppConsumeTime) + $(vReloadTimeDiffFromGMT),'YYYY-MM-DD hh:mm:ss') AS LargeAppConsumeDenialTime,
                TimeStamp(Ceil(Date(Date(Timestamp(LargeAppConsumeTime) + $(vReloadTimeDiffFromGMT),'YYYY-MM-DD hh:mm:ss')),1/24/60)) AS LargeAppConsumeDenialTimeMinute // using ceil it is one event with no duration so it provides the illusion of a short (sub 1 min) duration
            Resident LargeAppConsumption
            Where LargeAppConsumeQuotaType='com.qlik.v1.quota.allocation-failed'
            AND Date(Timestamp(LargeAppConsumeTime) + $(vReloadTimeDiffFromGMT),'YYYY-MM-DD hh:mm:ss')>=Date('$(vInitialDaysBack)');

            ///// Sort table by app id and timestamp asc
            Rename Table LargeAppConsumption To TEMP;

            LargeAppConsumption:
            Noconcatenate
            Load
                *
            Resident TEMP
            Where Match(LargeAppConsumeQuotaType,'com.qlik.v1.quota.consumed','com.qlik.v1.quota.released')
            AND Date(Timestamp(LargeAppConsumeTime) + $(vReloadTimeDiffFromGMT),'YYYY-MM-DD hh:mm:ss')>=Date('$(vInitialDaysBack)')
            Order By AppID, LargeAppConsumeTime ASC;

            Drop Table TEMP;

            ///// If a release event is the first for an app id, remove it
            Rename Table LargeAppConsumption To TEMP;

            LargeAppConsumption:
            NoConcatenate
            Load
                *
            Resident TEMP
            WHERE NOT (Peek('AppID')<>AppID AND LargeAppConsumeQuotaType='com.qlik.v1.quota.released');

            Drop Table TEMP;

            ///// Sort descending now
            Rename Table LargeAppConsumption To TEMP;

            LargeAppConsumption:
            Noconcatenate
            Load
                *
            Resident TEMP
            Order By AppID, LargeAppConsumeTime DESC;

            Drop Table TEMP;

            ///// If a consumed event is the last for an app id, remove it

            Rename Table LargeAppConsumption To TEMP;
            Rename Field LargeAppConsumeRemove To LargeAppConsumeRemoveTEMP;

            LargeAppConsumption:
            NoConcatenate
            Load
                *
            Resident TEMP
            Where Not (Peek('AppID')<>AppID AND LargeAppConsumeQuotaType='com.qlik.v1.quota.consumed');

            Drop Table TEMP;


            ///// Remove consumption events that don't have a release following them per app -- this is a suspected 
            ///// bug where a closure during app open won't log a release

            Rename Table LargeAppConsumption To TEMP;

            LargeAppConsumption:
            NoConcatenate
            Load
                *
            Resident TEMP
            Where Not (Peek('AppID')=AppID AND LargeAppConsumeQuotaType='com.qlik.v1.quota.consumed' AND Peek('LargeAppConsumeQuotaType')='com.qlik.v1.quota.consumed');

            DROP TABLE TEMP;

            ///// Remove duplicate consecutive release events and retain only the latest per app (this hasn't been observed but logic
            ///// is there in case.

            Rename Table LargeAppConsumption To TEMP;

            LargeAppConsumption:
            NoConcatenate
            Load
                *
            Resident TEMP
            Where Not (Peek('AppID')=AppID AND LargeAppConsumeQuotaType='com.qlik.v1.quota.released' AND Peek('LargeAppConsumeQuotaType')='com.qlik.v1.quota.released');

            DROP TABLE TEMP;

            ///// Sort ascending now
            Rename Table LargeAppConsumption To TEMP;

            LargeAppConsumption:
            Noconcatenate
            Load
                *
            Resident TEMP
            Order By AppID, LargeAppConsumeTime ASC;

            Drop Table TEMP;

            ///// Merge start and ends into a single record now that we've confirmed there are no dupes/standalone entries
            Rename Table LargeAppConsumption To TEMP;

            LargeAppConsumption:
            Load
                AppID,
                Timestamp(Timestamp(LargeAppConsumeTime) + $(vReloadTimeDiffFromGMT),'YYYY-MM-DD hh:mm:ss') AS LargeAppConsumeStartTime,
                RowNo() AS LargeAppConsumeID,
                'interactive' AS LargeAppConsumeQuotaGroup,
                Alt(LargeAppConsumeConsumed,LargeAppConsumeReleased) AS LargeAppConsumeAmount
            Resident TEMP
            Where LargeAppConsumeQuotaType = 'com.qlik.v1.quota.consumed';

            Left Join(LargeAppConsumption)
            Load
                AppID,
                Timestamp(Timestamp(LargeAppConsumeTime) + $(vReloadTimeDiffFromGMT),'YYYY-MM-DD hh:mm:ss') AS LargeAppConsumeEndTime,
                RowNo() AS LargeAppConsumeID,
                'interactive' AS LargeAppConsumeQuotaGroup
            Resident TEMP
            Where LargeAppConsumeQuotaType = 'com.qlik.v1.quota.released';

            Drop Table TEMP;

            ///// Create concurrency key for large apps
            Rename Table LargeAppConsumption To TEMP;

            LargeAppConsumption:
            Load
                *,
                AutoNumber(LargeAppConsumeStartTime&'|'&LargeAppConsumeEndTime,'LargeAppConsumptionExecutionConcurrency') as _LargeAppConsumptionExecutionConcurrencyKey
            Resident TEMP;

            Drop Table TEMP;

            ////////////////////////////////
            // Creating composite key of session and app data so that large app consumption data can be tied in
            ////////////////////////////////

            ConcurrencyLink:
            Load Distinct
                _ConsumptionExecutionConcurrencyKey,
                AppID,
                AutoNumber(_ConsumptionExecutionConcurrencyKey & '|' & AppID,'TimeAppConcurrency') AS _TimeAppConcurrencyKey
            Resident Consumption;

            Rename Table ConumptionConcurrencyMinutes To TEMP;

            Join(ConcurrencyLink)
            Load
                _ConsumptionExecutionConcurrencyKey,
                ConsumptionConcurrencyMinute
            Resident TEMP;

            Drop Table TEMP;

            Rename Table ConcurrencyLink To TEMP;

            ConcurrencyLink:
            Load
                AutoNumber(AppID & '|' & ConsumptionConcurrencyMinute,'LargeAppConsumeConcurrencyKey') AS _LargeAppConsumeConcurrencyKey,
                AppID & '|' & ConsumptionConcurrencyMinute AS RemoveForDupes,
                *
            Resident TEMP;

            Drop Table TEMP;

            Rename Table Consumption To TEMP;

            Consumption:
            Load
                SessionStartTimeDate,
                AutoNumber(_ConsumptionExecutionConcurrencyKey & '|' & AppID,'TimeAppConcurrency') AS _TimeAppConcurrencyKey,
                SessionID,
                SessionUserID,
                SessionDurationMinutes,
                SessionCapacityUsed,
                SessionMinutesUsed,
                SessionLicenseUsage,
                SessionDurationMS,
                SessionDurationInterval,
                SessionEndTime,
                SessionEndTimeDate,
                SessionUserName,
                SessionUserSubject,
                SessionUserIsOAuthClient,
                SessionStartTime,
                SessionStartTimeDateHourFloored,
                SessionHour,
                SessionMinute,
                SessionHourAMPM,
                AppNotAccessedInOver90Days,
                AppNotAccessedInOver60Days,
                AppNotAccessedInOver30Days
            Resident TEMP;

            Drop Table TEMP;

            ////////////////////////////////
            // Generate minute by minute data for large app concurrency
            ////////////////////////////////

            LargeAppSessionMinMaxDates:
            Load
                Floor(Min("LargeAppConsumeStartTime"),1/24/60) AS "Large App Session Start Time Min",
                Ceil(Max("LargeAppConsumeEndTime"),1/24/60) AS "Large App Session End Time Max"
            Resident LargeAppConsumption;

            Let vLargeAppConsumptionMinDate = Peek('Large App Session Start Time Min',0,'LargeAppSessionMinMaxDates');
            Let vLargeAppConsumptionMaxDate = Peek('Large App Session End Time Max',0,'LargeAppSessionMinMaxDates');

            Drop Table LargeAppSessionMinMaxDates;

            Let vLargeAppMinutes = Ceil(($(vLargeAppConsumptionMaxDate)-$(vLargeAppConsumptionMinDate))*24*(60/$(vConsumptionMinutes)));

            LargeAppConsumptionMinutesTemp:
            Load Distinct
                TimeStamp(Floor(Date($(vLargeAppConsumptionMinDate)+((1/24/(60/$(vConsumptionMinutes)))*RowNo())),1/24/60)) as LargeAppConsumptionConcurrencyMinute
            Autogenerate $(vLargeAppMinutes);

            Left Join
            IntervalMatch (LargeAppConsumptionConcurrencyMinute) 
            Load 
                LargeAppConsumeStartTime,
                LargeAppConsumeEndTime
            Resident LargeAppConsumption;

            LargeAppConsumptionConcurrencyMinutes:
            Left Keep (LargeAppConsumption)
            Load
                Timestamp(LargeAppConsumptionConcurrencyMinute,'YYYY-MM-DD hh:mm:ss') as LargeAppConsumptionConcurrencyMinute,
                AutoNumber(LargeAppConsumeStartTime&'|'&LargeAppConsumeEndTime,'LargeAppConsumptionExecutionConcurrency') as _LargeAppConsumptionExecutionConcurrencyKey
            Resident LargeAppConsumptionMinutesTemp;

            Drop Table LargeAppConsumptionMinutesTemp;

            // Join app id onto large app consume
            Left Join (LargeAppConsumptionConcurrencyMinutes)
            Load
                _LargeAppConsumptionExecutionConcurrencyKey,
                AppID
            Resident LargeAppConsumption;

            // Remove AppID from LargeAppConsumption
            Rename Table LargeAppConsumption To TEMP;

            LargeAppConsumption:
            Load
                _LargeAppConsumptionExecutionConcurrencyKey,
                LargeAppConsumeQuotaGroup,
                LargeAppConsumeStartTime,
                LargeAppConsumeID,
                LargeAppConsumeAmount,
                LargeAppConsumeEndTime
            Resident TEMP;

            // Stack large app consume minutes onto link that do not have matching sessions to preserve link to app id
            Concatenate(ConcurrencyLink)
            Load
                AutoNumber(AppID & '|' & LargeAppConsumptionConcurrencyMinute,'LargeAppConsumeConcurrencyKey') AS _LargeAppConsumeConcurrencyKey,
                AppID
            Resident LargeAppConsumptionConcurrencyMinutes
            Where Not Exists(RemoveForDupes,AppID & '|' & LargeAppConsumptionConcurrencyMinute);

            Drop Table TEMP;
            Drop Field RemoveForDupes;

            // Create composite of app id and time to link to session concurrency
            Rename Table LargeAppConsumptionConcurrencyMinutes To TEMP;

            LargeAppConsumptionConcurrencyMinutes:
            Load
                _LargeAppConsumptionExecutionConcurrencyKey,
                AutoNumber(AppID & '|' & LargeAppConsumptionConcurrencyMinute,'LargeAppConsumeConcurrencyKey') AS _LargeAppConsumeConcurrencyKey,
                LargeAppConsumptionConcurrencyMinute,
                'True' AS LargeAppConsume,
                'False' AS LargeAppConsumeIsDenied,
                Date(Floor(LargeAppConsumptionConcurrencyMinute,1/24)) AS LargeAppConsumptionConcurrencyHour
            Resident TEMP;

            // Stack on denial events
            Concatenate(LargeAppConsumptionConcurrencyMinutes)
            Load
                AutoNumber(AppID & '|' & LargeAppConsumeDenialTimeMinute,'LargeAppConsumeConcurrencyKey') AS _LargeAppConsumeConcurrencyKey,
                AutoNumber(LargeAppConsumeDenialTimeMinute&'|'&LargeAppConsumeDenialTimeMinute,'LargeAppConsumptionExecutionConcurrency') as _LargeAppConsumptionExecutionConcurrencyKey,
                LargeAppConsumeDenialTimeMinute AS LargeAppConsumptionConcurrencyMinute,
                Date(Floor(LargeAppConsumeDenialTimeMinute,1/24)) AS LargeAppConsumptionConcurrencyHour,
                'True' AS LargeAppConsume,
                'True' AS LargeAppConsumeIsDenied
            Resident LargeAppConsumptionDenials;

            // Stack on denial details
            Concatenate(LargeAppConsumption)
            Load
                AutoNumber(LargeAppConsumeDenialTimeMinute&'|'&LargeAppConsumeDenialTimeMinute,'LargeAppConsumptionExecutionConcurrency') as _LargeAppConsumptionExecutionConcurrencyKey,
                LargeAppConsumeDenialQuotaGroup AS LargeAppConsumeQuotaGroup,
                LargeAppConsumeDenialRequested AS LargeAppConsumeRequested,
                LargeAppConsumeDenialLimit AS LargeAppConsumeLimit,
                LargeAppConsumeDenialTime AS LargeAppConsumeStartTime,
                LargeAppConsumeDenialTime AS LargeAppConsumeEndTime,
                LargeAppConsumeDenialAmount AS LargeAppConsumeAmount,
                RowNo() AS LargeAppConsumeID
            Resident LargeAppConsumptionDenials;

            // There are no sessions associated with denial events, so we need to fabricate them and stack them on
            Concatenate(ConcurrencyLink)
            Load
                AutoNumber(AppID & '|' & LargeAppConsumeDenialTimeMinute,'LargeAppConsumeConcurrencyKey') AS _LargeAppConsumeConcurrencyKey,
                AutoNumber(AutoNumber(LargeAppConsumeDenialTimeMinute & '|' & LargeAppConsumeDenialTimeMinute,'ConsumptionConcurrency') & '|' & AppID,'TimeAppConcurrency') AS _TimeAppConcurrencyKey,
                AppID,
                LargeAppConsumeDenialTimeMinute AS ConsumptionConcurrencyMinute
            Resident LargeAppConsumptionDenials;

            Concatenate(Consumption)
            Load
                Date(Floor(LargeAppConsumeDenialTimeMinute)) AS SessionStartTimeDate,
                AutoNumber(AutoNumber(LargeAppConsumeDenialTimeMinute & '|' & LargeAppConsumeDenialTimeMinute,'ConsumptionConcurrency') & '|' & AppID,'TimeAppConcurrency') AS _TimeAppConcurrencyKey,
                AutoNumber(RowNo() & '|' & AppID,'Session') AS SessionID,
                LargeAppConsumeDenialUserID AS SessionUserID,
                If(WildMatch(LargeAppConsumeDenialUserID,'qau-*'),'[Anonymous User]',ApplyMap('Map_UserID_AppOwnerName',LargeAppConsumeDenialUserID,'[Deleted]')) as SessionUserName,
                If(WildMatch(LargeAppConsumeDenialUserID,'qau-*'),'[Anonymous User]',ApplyMap('Map_UserID_AppOwnerSubject',LargeAppConsumeDenialUserID,'[Deleted]')) as SessionUserSubject,
                If(ApplyMap('Map_OAuthClientName',If(WildMatch(LargeAppConsumeDenialUserID,'qau-*'),'[Anonymous User]',ApplyMap('Map_UserID_AppOwnerName',LargeAppConsumeDenialUserID,'[Deleted]')) & '|' & ApplyMap('Map_AppID_TenantID',AppID,Null()))=1,'True','False') as SessionUserIsOAuthClient,
                0 AS SessionDurationMinutes,
                1 AS SessionCapacityUsed,
                0 AS SessionMinutesUsed,
                'ASSIGNED_LICENSE' AS SessionLicenseUsage,
                0 as SessionDurationMS,
                Interval(0) AS SessionDurationInterval,
                LargeAppConsumeDenialTime AS SessionEndTime,
                Date(Floor(LargeAppConsumeDenialTime)) AS SessionEndTimeDate,
                LargeAppConsumeDenialTime AS SessionStartTime,
                Date(Floor(LargeAppConsumeDenialTime,1/24)) AS SessionStartTimeDateHourFloored,
                Hour(LargeAppConsumeDenialTime) AS SessionHour,
                Minute(LargeAppConsumeDenialTime) AS SessionMinute,
                Dual(Text(Time(LargeAppConsumeDenialTime,'h TT')),Hour(LargeAppConsumeDenialTime)) AS SessionHourAMPM,
                If(Date(Floor(LargeAppConsumeDenialTime))<$(vLast90Days),'True','False') as AppNotAccessedInOver90Days,
                If(Date(Floor(LargeAppConsumeDenialTime))<$(vLast60Days),'True','False') as AppNotAccessedInOver60Days,
                If(Date(Floor(LargeAppConsumeDenialTime))<$(vLast30Days),'True','False') as AppNotAccessedInOver30Days
            Resident LargeAppConsumptionDenials;

            Drop Table LargeAppConsumptionDenials;

            Drop Table TEMP;
            Drop Field _ConsumptionExecutionConcurrencyKey;

            // Remove dupes
            RENAME TABLE ConcurrencyLink To TEMP;

            ConcurrencyLink:
            Noconcatenate
            Load Distinct
                *
            Resident TEMP;

            Drop Table TEMP;
            
        End If

    Else
    
    	Drop Field _ConsumptionExecutionConcurrencyKey;
        Drop Field SessionUserID From SheetConsumption;
        Drop Field SessionUserIDTemp;

    End If
     
End Sub;

///$tab Calendar
Sub calendar

    // Built off of timestamp, not off of date as changes would break the OEM Dashboard
    Trace Working on master Calendar for AppLastReloadTime;

    AppLastReloadTime:
    Load Distinct 
        AppLastReloadTime,
        Month(AppLastReloadTime)															as Month,
        WeekStart(AppLastReloadTime) 														as [Week Beginning],
        MakeDate(Year(AppLastReloadTime),Month(AppLastReloadTime),Day(AppLastReloadTime)) 	as Date,
        If(AppLastReloadTime>=$(vLast7Days),1,0) 											as last7days,
        If(AppLastReloadTime>=$(vLast30Days),1,0) 											as last30days,
        If(AppLastReloadTime>=$(vLast60Days),1,0)											as last60days,
        If(AppLastReloadTime>=$(vLast90Days),1,0)											as last90days
    Resident Apps
    Order By AppLastReloadTime desc;

    // Establish Sort Order of Timeframe
    timeframe_temp:
    Load * Inline [
        Timeframe
        Last 7 Days
        Last 30 Days
        Last 60 Days
        Last 90 Days
    ];

    Last_AppLastReloadTime:
    NoConcatenate Load Distinct AppLastReloadTime, 'Last 7 Days'  as [Timeframe] Resident AppLastReloadTime Where last7days=1;
    Concatenate (Last_AppLastReloadTime) Load Distinct AppLastReloadTime, 'Last 30 Days' as [Timeframe] Resident AppLastReloadTime Where last30days=1;
    Concatenate (Last_AppLastReloadTime) Load Distinct AppLastReloadTime, 'Last 60 Days' as [Timeframe] Resident AppLastReloadTime Where last60days=1;
    Concatenate (Last_AppLastReloadTime) Load Distinct AppLastReloadTime, 'Last 90 Days' as [Timeframe] Resident AppLastReloadTime Where last90days=1;

    Drop Fields last7days,last30days,last60days,last90days;
    Drop Table timeframe_temp;
    
    //SessionStartTime
    Trace Working on master Calendar for SessionStartDate;
    
    Let vStartTimeGMTOffset = TimeStamp(TimeStamp('$(vStartTime)') + $(vReloadTimeDiffFromGMT));

	// Built off of date
    SessionStartTime:
    Load Distinct 
        SessionStartTimeDate,
        Month(SessionStartTimeDate)			 								as SessionMonth,
        Year(SessionStartTimeDate)			 								as SessionYear,
        Dual(Month(SessionStartTimeDate) & '-' & Year(SessionStartTimeDate),MonthStart(SessionStartTimeDate)) AS SessionMonthYear,
        Day(SessionStartTimeDate)											as SessionDay,
        WeekStart(SessionStartTimeDate) 									as SessionWeekBeginning,
        If(SessionStartTimeDate>=$(vLast7Days),1,0) 						as SessionLast7Days,
        If(SessionStartTimeDate>=$(vLast30Days),1,0) 						as SessionLast30Days,
        If(SessionStartTimeDate>=$(vLast60Days),1,0)						as SessionLast60Days,
        If(SessionStartTimeDate>=$(vLast90Days),1,0)						as SessionLast90Days,
        If(InMonth(SessionStartTimeDate,'$(vStartTime)',0),1,0) 			as SessionInCurrentMTD,
        If(InMonth(SessionStartTimeDate,'$(vStartTime)',-1),1,0) 			as SessionInPriorMonth,
        If(InMonthToDate(SessionStartTimeDate,'$(vStartTime)',-1),1,0) 		as SessionInPriorMTD
    Resident Consumption
    Order By SessionStartTimeDate desc;

    // Establish Sort Order of Timeframe
    timeframe_temp:
    Load * Inline [
        SessionTimeframe
        Last 7 Days
        Last 30 Days
        Last 60 Days
        Last 90 Days
    ];

    Last_SessionStartDate:
    NoConcatenate Load Distinct SessionStartTimeDate, 'Last 7 Days'  as [SessionTimeframe] Resident SessionStartTime Where SessionLast7Days=1;
    Concatenate (Last_SessionStartDate) Load Distinct SessionStartTimeDate, 'Last 30 Days' as [SessionTimeframe] Resident SessionStartTime Where SessionLast30Days=1;
    Concatenate (Last_SessionStartDate) Load Distinct SessionStartTimeDate, 'Last 60 Days' as [SessionTimeframe] Resident SessionStartTime Where SessionLast60Days=1;
    Concatenate (Last_SessionStartDate) Load Distinct SessionStartTimeDate, 'Last 90 Days' as [SessionTimeframe] Resident SessionStartTime Where SessionLast90Days=1;

    Drop Fields SessionLast7Days,SessionLast30Days,SessionLast60Days,SessionLast90Days;
    Drop Table timeframe_temp;

End Sub

///$tab Autonumber
Sub autonumber

	Drop Field _app_meta_key;
	Autonumber _KeyFields, _KeyTags, ExportFromAppTransactionID;

    Left Join(Spaces)
    Load Distinct
    	SpaceID,
        Dual(SpaceName,AutoNumber(SpaceID)) as SpaceNameUnique
    Resident Spaces;
    
    Left Join(Apps)
    Load Distinct
    	AppID,
        Dual(AppName,AutoNumber(AppID)) as AppNameUnique
    Resident Apps;
    
    If NoOfRows('map_key_fields_table_id') > 0 then
    Else
        // Create mapping tables for FieldNameUnique dualing with App GUIDs
        map_key_fields_table_id:
        Mapping Load Distinct
            [_KeyFields],
            TableID
        Resident FieldSourceTables;

        map_table_id_app_id:
        Mapping Load Distinct
            TableID,
            AppID
        Resident Tables;
    End If
    
    Left Join(Fields)
    Load Distinct
    	_KeyFields,
        Dual(FieldName,AutoNumber(FieldName & '_' & ApplyMap('map_table_id_app_id',ApplyMap('map_key_fields_table_id',_KeyFields)))) as FieldNameUnique
    Resident Fields;
    
    Left Join(Tables)
    Load Distinct
    	TableID,
        Dual(TableName,AutoNumber(TableName & '_' & AppID)) as TableNameUnique
    Resident Tables;
    
End Sub
///$tab Slim
Sub slim

	If $(vu_slim_version_for_anonymous)=1 Then
    
    	Drop Tables 
            ServerHardware
            ,Last_SessionStartDate
            ,FieldTags
            ,FieldSourceTables
            ,Fields
            ,Tables
            ,Users
            ,AppLastReloadTime
            ,Last_AppLastReloadTime
            ,AppTags
            ,app_analyzer_rolling
        ;
        
        Drop Fields
        	_KeyTags
			,QuotaUsage
            ,ExportFromAppSuccessful
            ,ExportFromAppEndTime
            ,ExportFromAppStartTime
            ,AppType
            ,SessionStartTimeDateHourFloored
            ,SessionLicenseUsage
            ,SpaceOwnerID
            ,SpaceDescription
            ,SpaceCreatedTime
            ,SpaceCreatedBy
            ,AppOwnerID
            ,AppCreatedTime
            ,AppUpdatedTime
            ,AppCreatorID
            ,AppUpdaterID
            ,AppIsFavorited
            ,AppDescription
            ,AppIsDistributed
            ,AppHasSectionAccess
            ,AppLastReloadTimeLocalServerTime
            ,AppOriginalID
            ,AppPublishedTime
            ,AppEncrypted
            ,_AppOwnerSubjectForOEMDash
            ,[App Reload CPU Time (ms)]
            ,AppHasDirectQueryMode
            ,AppLastReloadedBucket
            ,AppPeakRAMOverThreshold
            ,AppReloadCPUTimeOverThreshold
            ,AppNoOfTables
            ,AppContainsSyntheticKeys
            ,[AppContainsDataIsland(s)]
            ,AppNumberOfDistinctFields
            ,AppTableNoOfRows
            ,[AppContainsCircularReference(s)]
            ,AppTableNoOfRowsOverThreshold
            ,AppNumberOfDistinctFieldsOverThreshold
            ,AppRAMOverThreshold
            ,AppRAMPercentToQuota
            ,_AppRAMPercentToQuotaColor
            ,AppRAMPeakReloadPercentToQuota
            ,_AppRAMPeakReloadPercentToQuotaColor
        ;
            
    End if;

End Sub
///$tab Helper Functions
Sub execute_sub(sub_routine)
    Trace Working on $(sub_routine);
    Let sub_start = Num(Now(1));
    Call $(sub_routine)
    Let sub_finish = Num(Now(1));
    Let sub_duration = Num(Round((sub_finish-sub_start)*86400),'#,##0');
    Trace $(sub_routine) completed after $(sub_duration) seconds.;
End Sub
///$tab Reload Logic
Let reload_start = Now(1);
//// App Variables & Messaging
// Reset these variables
Set ahora = ; 
Set msg =; 
Set startMsg=; 
Set comp=;
Let vTenants = 0;

Set app_name			= 'App Analyzer';
Set app_version			= '6.5.0';
Set app_schema_version	= 'sv_1.0.1';
Let comp 				= ComputerName(); 
Let engine_ver 			= PurgeChar(EngineVersion(),Chr(39)); 
Let startMsg 			= 'Reloading $(app_name) v$(app_version) from $(comp) running QIX Engine version $(engine_ver)';

Trace $(startMsg);

Sub load_core_data
    Trace Loading data...;
    For Each sub_routine in 'get_tenant_metadata','check_license','check_version','get_quota','get_oauth_clients','get_users','get_spaces','get_apps','get_consumption','get_audit_sheet_consumption','get_audit_export_from_app','get_audit_large_app_consumption','app_metadata'
        Call execute_sub(sub_routine)
    Next sub_routine
    
    If $(vu_track_app_meta_over_time) then
        Call store_app_meta_rolling
    Else
    	Let file_size_app_analyzer_rolling = 0;
    End If
End Sub

Sub transform_data
    Trace Transforming data...;
    For Each sub_routine in 'transform','calendar','autonumber','slim'
        Call execute_sub(sub_routine)
    Next sub_routine
End Sub


// Main
If $(vu_multi_tenant_enabled)=1 then 
    If $(vu_is_parent_app)=1 then
        Trace This application is configured for a Multitenant setup and has been designated as a **Parent** app.;
        Trace This application will attempt to load all of the QVDs that have been generated for the $(app_name) within the "QlikMetaCollection" folder found within "$(vu_qlik_meta_collection_parent_dir)";
        Trace This application will then store all resulting QVDs to a "CompiledTenants" directory.;
        
        Call execute_sub('variables')
        Call execute_sub('set_incremental')
        Call execute_sub('load_multi_tenant_qvds(''$(vu_qlik_meta_collection_parent_dir)'',''Monitoring'',''$(app_name)'')')

        If $(vTenants)>0 then
            Call transform_data
        End If
        
        Trace This application will attempt to store all of the tables from this model to the "QlikMetaCollection/CompiledTenants" folder found within $(vu_qlik_meta_collection_parent_dir);
  		Call execute_sub('write_tenant_qvds(''$(vu_qlik_meta_collection_parent_dir)'',''Monitoring'',''$(app_name)'',1)')
        
        Trace Data fetched from $(vTenants) tenants.;
    Else
        Trace This application is configured for a Multitenant setup and has been designated as a **Child** app.;
        Trace This application will attempt to store all of the tables from this model to the "QlikMetaCollection" folder found within "$(vu_qlik_meta_collection_parent_dir)";
		
        Call execute_sub('variables')
        Call execute_sub('set_incremental')
        Call load_core_data
        Call execute_sub('write_tenant_qvds(''$(vu_qlik_meta_collection_parent_dir)'',''Monitoring'',''$(app_name)'',0)')
        Call transform_data
    End If
Else
    Call execute_sub('variables')
    Call execute_sub('set_incremental')
    Call load_core_data
    Call transform_data

    Trace Data fetched from $(vu_tenant_fqdn);
End If

Let reload_end = Now(1);
Let reload_duration = Num(Ceil((reload_end-reload_start)*86400),'#,##0');
Let reload_message = 'At $(reload_end), $(app_name) v$(app_version) finished reloading on $(comp) (QIX Engine $(engine_ver)) after $(reload_duration) seconds.';
Trace $(reload_message);

If vu_app_metadata_initial_days_back <> -1 Then
	Trace ***WARNING*** This app contains only partially loaded app metadata. The "vu_app_metadata_initial_days_back" variable will need to be set to '-1' for certain sheets to be viewed. Ensure this is set back after batch reloading.;
End If